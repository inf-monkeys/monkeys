File Structure:
├── database.module.ts
│   entities
│   │   apikey
│   │   └── apikey.ts
│   │   assets
│   │   ├── asset-authorization.ts
│   │   ├── asset-filter.ts
│   │   ├── asset-marketplace-tag-relations.ts
│   │   ├── asset-marketplace-tag.ts
│   │   ├── asset-tag-definitions.ts
│   │   ├── asset-tag-relations.ts
│   │   ├── base-asset.ts
│   │   │   canvas
│   │   │   └── canvas.ts
│   │   │   knowledge-base
│   │   │   ├── knowledge-base-sql.entity.ts
│   │   │   └── knowledge-base.entity.ts
│   │   │   media
│   │   │   └── media-file.ts
│   │       model
│   │       │   comfyui-model
│   │       │   ├── comfyui-model-server-relation.entity.ts
│   │       │   ├── comfyui-model-type.entity.ts
│   │       │   └── comfyui-model.entity.ts
│   │       │   llm-channel
│   │       │   └── llm-channel.entity.ts
│   │       │   llm-model
│   │       │   └── llm-model.ts
│   │           sd-model
│   │           └── sd-model.ts
│   │   base
│   │   └── base.ts
│   │   comfyui
│   │   ├── comfyui-server.entity.ts
│   │   └── comfyui-workflow.entity.ts
│   │   config
│   │   └── theme.ts
│   │   conversation-app
│   │   ├── conversation-app.entity.ts
│   │   └── conversation-executions.entity.ts
│   │   identity
│   │   ├── team-invites.ts
│   │   ├── team-join-request.ts
│   │   ├── team.ts
│   │   ├── user-team-relationship.ts
│   │   └── user.ts
│   │   observability
│   │   ├── team-observability.ts
│   │   └── workflow-observability.ts
│   │   oneapi
│   │   └── oneapi-user.entity.ts
│   │   system
│   │   └── system-configuration.entity.ts
│   │   tools
│   │   ├── tools-credential-type.entity.ts
│   │   ├── tools-credential.entity.ts
│   │   ├── tools-server.entity.ts
│   │   ├── tools-trigger-types.ts
│   │   └── tools.entity.ts
│       workflow
│       ├── workflow-chat-session.ts
│       ├── workflow-execution.ts
│       ├── workflow-metadata.ts
│       ├── workflow-page-group.ts
│       ├── workflow-page.ts
│       ├── workflow-template.ts
│       └── workflow-trigger.ts
│   migrations
│   ├── 1714373691606-migartion.ts
│   ├── 1715926119511-add-table-comfyui-workflow.ts
│   ├── 1716396543601-add-columns-for-comfyui-workflow.ts
│   ├── 1716551483943-add-column-log-endpoint-for-tools-server.ts
│   ├── 1716972169705-add-table-team-invites-migartion.ts
│   ├── 1716975090536-add-table-comfyui-servers-migartion.ts
│   ├── 1717388296249-add-column-create-type-for-table-sql-knowledge-base.ts
│   ├── 1717660927388-remove-built-comfyui-workflow-data.ts
│   ├── 1717735898524-add-column-tool-output-for-comfyui-workflowmigartion.ts
│   ├── 1717992010830-add-column-encryped-data.ts
│   ├── 1717992114097-add-column-rsa-public-key.ts
│   ├── 1718360897700-add-column-openai-model-namemigartion.ts
│   ├── 1718809374824-alter-rich-media-size-to-nullablemigartion.ts
│   ├── 1718959051307-add-table-llm-channel-migartion.ts
│   ├── 1719200817122-add-table-oneapi-user.ts
│   ├── 1719215095828-add-table-llm-models-migartion.ts
│   ├── 1720670723210-add-column-not-authorized-migartion.ts
│   ├── 1720683214065-workflow-page-group-migartion.ts
│   ├── 1720748707927-add-default-group-for-all-built-in-pages-migartion.ts
│   ├── 1721115912596-add-column-for-table-workflow-execution-migartion.ts
│   ├── 1721116431677-add-index-for-table-workflow-execution-migartion.ts
│   ├── 1721121604853-add-column-apikey-for-workflow-execution-migartion.ts
│   ├── 1722223140728-add-table-conversation-app.ts
│   ├── 1722324247892-migartion.ts
│   ├── 1723111778658-conversation-app-prompt-migartion.ts
│   ├── 1724846191510-add-table-comfyui-models-types-relations.ts
│   ├── 1724905499551-alter-comfyui-model-table.ts
│   ├── 1730138526826-add-column.ts
│   ├── 1732626882020-add-shortcuts-flow-to-workflow-metadata-migartion.ts
│   ├── 1732669696629-add-column-execution-group-migartion.ts
│   ├── 1745922805471-add-table-workflow-observability-migartion.ts
│   ├── 1746762866441-add-darkmode-team-icon.ts
│   ├── 1748344827526-migartion.ts
│   ├── 1748510326422-migartion.ts
│   │   columns
│   │   └── index.ts
│       utils
│       └── index.ts
│   repositories
│   ├── apikey.repository.ts
│   ├── assets-abstract.repository.ts
│   ├── assets-canvas.repository.ts
│   ├── assets-comfyui-model-type.repositor.ts
│   ├── assets-comfyui-model.repository.ts
│   ├── assets-comfyui-workflow.respository.ts
│   ├── assets-common.repository.ts
│   ├── assets-conversation-app.repository.ts
│   ├── assets-knowledge-base-sql.repository.ts
│   ├── assets-knowledge-base.repository.ts
│   ├── assets-llm-channel.respository.ts
│   ├── assets-llm-model.respository.ts
│   ├── assets-marketplace.repository.ts
│   ├── assets-media-file.repository.ts
│   ├── assets-sd-model.repository.ts
│   ├── assets-workflow.respository.ts
│   ├── comfyui-model.repository.ts
│   ├── comfyui.repository.ts
│   ├── conversation-app.repository.ts
│   ├── credential.repository.ts
│   ├── knowledge-base-sql.repository.ts
│   ├── knowledge-base.repository.ts
│   ├── llm-model.repository.ts
│   ├── media.repository.ts
│   ├── observability.repository.ts
│   ├── oneapi.respository.ts
│   ├── sd-model.repository.ts
│   ├── system-configuration.repository.ts
│   ├── team.repository.ts
│   ├── tools.repository.ts
│   ├── trigger-type.repository.ts
│   ├── user.repository.ts
│   └── workflow.repository.ts
├── repositories.module.ts
    transformers
    └── timestamp.transformer.ts


================================================================================
File Contents:
================================================================================

database.module.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { ThemeEntity } from '@/database/entities/config/theme';
import { TeamInvitesRequestsEntity } from '@/database/entities/identity/team-invites';
import { SystemConfigurationEntity } from '@/database/entities/system/system-configuration.entity';
import { ToolsCredentialTypeEntity } from '@/database/entities/tools/tools-credential-type.entity';
import { ToolsCredentialEntity } from '@/database/entities/tools/tools-credential.entity';
import { ToolsServerEntity } from '@/database/entities/tools/tools-server.entity';
import { ToolsEntity } from '@/database/entities/tools/tools.entity';
import { WorkflowChatSessionEntity } from '@/database/entities/workflow/workflow-chat-session';
import { WorkflowExecutionEntity } from '@/database/entities/workflow/workflow-execution';
import { WorkflowMetadataEntity } from '@/database/entities/workflow/workflow-metadata';
import { WorkflowPageGroupEntity } from '@/database/entities/workflow/workflow-page-group';
import { WorkflowTemplateEntity } from '@/database/entities/workflow/workflow-template';
import { WorkflowTriggersEntity } from '@/database/entities/workflow/workflow-trigger';
import { TimestampSubscriber } from '@/timestamp.subscriber';
import { TypeOrmModule } from '@nestjs/typeorm';
import { EntityClassOrSchema } from '@nestjs/typeorm/dist/interfaces/entity-class-or-schema.type';
import { ApiKeyEntity } from './entities/apikey/apikey';
import { AssetsAuthorizationEntity } from './entities/assets/asset-authorization';
import { AssetFilterEntity } from './entities/assets/asset-filter';
import { AssetsMarketPlaceTagEntity } from './entities/assets/asset-marketplace-tag';
import { AssetsMarketplaceTagRelationsEntity } from './entities/assets/asset-marketplace-tag-relations';
import { AssetsTagEntity } from './entities/assets/asset-tag-definitions';
import { AssetsTagRelationsEntity } from './entities/assets/asset-tag-relations';
import { CanvasApplicationEntity } from './entities/assets/canvas/canvas';
import { SqlKnowLedgeBaseEntity } from './entities/assets/knowledge-base/knowledge-base-sql.entity';
import { KnowLedgeBaseEntity } from './entities/assets/knowledge-base/knowledge-base.entity';
import { MediaFileEntity } from './entities/assets/media/media-file';
import { ComfyuiModelServerRelationEntity } from './entities/assets/model/comfyui-model/comfyui-model-server-relation.entity';
import { ComfyuiModelTypeEntity } from './entities/assets/model/comfyui-model/comfyui-model-type.entity';
import { ComfyuiModelEntity } from './entities/assets/model/comfyui-model/comfyui-model.entity';
import { LlmChannelEntity } from './entities/assets/model/llm-channel/llm-channel.entity';
import { LlmModelEntity } from './entities/assets/model/llm-model/llm-model';
import { SdModelEntity } from './entities/assets/model/sd-model/sd-model';
import { ComfyuiServerEntity } from './entities/comfyui/comfyui-server.entity';
import { ComfyuiWorkflowEntity } from './entities/comfyui/comfyui-workflow.entity';
import { ConversationAppEntity } from './entities/conversation-app/conversation-app.entity';
import { ConversationExecutionEntity } from './entities/conversation-app/conversation-executions.entity';
import { TeamEntity } from './entities/identity/team';
import { TeamJoinRequestsEntity } from './entities/identity/team-join-request';
import { UserEntity } from './entities/identity/user';
import { TeamMembersEntity } from './entities/identity/user-team-relationship';
import { WorkflowObservabilityEntity } from './entities/observability/workflow-observability';
import { OneApiUsersEntity } from './entities/oneapi/oneapi-user.entity';
import { ToolsTriggerTypesEntity } from './entities/tools/tools-trigger-types';
import { WorkflowPageEntity } from './entities/workflow/workflow-page';

export const entities: EntityClassOrSchema[] = [
  ThemeEntity,
  ToolsEntity,
  ToolsCredentialTypeEntity,
  ToolsCredentialEntity,
  ToolsServerEntity,
  ToolsTriggerTypesEntity,
  WorkflowExecutionEntity,
  WorkflowMetadataEntity,
  WorkflowChatSessionEntity,
  WorkflowTriggersEntity,
  WorkflowTemplateEntity,
  SystemConfigurationEntity,
  UserEntity,
  TeamEntity,
  TeamMembersEntity,
  TeamInvitesRequestsEntity,
  ApiKeyEntity,
  WorkflowPageEntity,
  WorkflowPageGroupEntity,
  LlmModelEntity,
  LlmChannelEntity,
  SdModelEntity,
  KnowLedgeBaseEntity,
  MediaFileEntity,
  AssetFilterEntity,
  AssetsTagEntity,
  CanvasApplicationEntity,
  AssetsAuthorizationEntity,
  AssetsTagRelationsEntity,
  TeamJoinRequestsEntity,
  SqlKnowLedgeBaseEntity,
  AssetsMarketPlaceTagEntity,
  AssetsMarketplaceTagRelationsEntity,
  ComfyuiWorkflowEntity,
  ComfyuiServerEntity,
  ComfyuiModelEntity,
  ComfyuiModelTypeEntity,
  ComfyuiModelServerRelationEntity,
  OneApiUsersEntity,
  ConversationAppEntity,
  ConversationExecutionEntity,
  WorkflowObservabilityEntity,
];

export const DatabaseModule = TypeOrmModule.forRoot({
  ...config.database,
  entityPrefix: config.server.appId.concat('_'),
  entities: entities,
  subscribers: [TimestampSubscriber],
});

================================================================================

entities/apikey/apikey.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export enum ApiKeyStatus {
  Valid = 'valid',
  Revoked = 'revoked',
}

@Entity({ name: 'apikey' })
export class ApiKeyEntity extends BaseEntity {
  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'creator_user_id',
  })
  creatorUserId: string;

  @Column({
    name: 'api_key',
  })
  apiKey: string;

  @Column({
    type: 'varchar',
  })
  status: ApiKeyStatus;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  desc?: string;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  applicationId?: string;

  // 私有的 ApiKey 是由后端逻辑创建的，不会被返回给前端
  @Column({
    type: 'boolean',
    default: false,
  })
  isPrivate?: boolean;
}

================================================================================

entities/assets/asset-authorization.ts:
--------------------------------------------------------------------------------
import { TargetType } from '@/common/typings/asset';
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export interface AssetFilterRule {
  createdTimestamp?: [number, number];
  updatedTimestamp?: [number, number];
  tagIds?: string[];
  userIds?: string[];
}

@Entity({ name: 'assets_authorization' })
export class AssetsAuthorizationEntity extends BaseEntity {
  @Column({
    name: 'asset_type',
    type: 'varchar',
  })
  assetType: AssetType;

  @Column({
    name: 'asset_id',
    type: 'varchar',
  })
  assetId: string;

  @Column({
    name: 'target_type',
    type: 'varchar',
  })
  targetType: TargetType;

  @Column({
    name: 'target_id',
    type: 'varchar',
  })
  targetId: string;
}

================================================================================

entities/assets/asset-filter.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export interface AssetFilterRule {
  createdTimestamp?: [number, number];
  updatedTimestamp?: [number, number];
  tagIds?: string[];
  userIds?: string[];
}

@Entity({ name: 'asset_filters' })
export class AssetFilterEntity extends BaseEntity {
  @Column({
    name: 'team_id',
    type: 'varchar',
  })
  teamId: string;

  @Column()
  name: string;

  @Column({
    name: 'creator_user_id',
    type: 'varchar',
    nullable: true,
  })
  creatorUserId: string;

  @Column({
    name: 'asset_type',
    type: 'varchar',
    nullable: true,
  })
  assetType?: AssetType;

  @Column({
    type: 'simple-json',
    nullable: true,
  })
  rules: AssetFilterRule;
}

================================================================================

entities/assets/asset-marketplace-tag-relations.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'asset_marketplace_tag_relations' })
export class AssetsMarketplaceTagRelationsEntity extends BaseEntity {
  @Column({
    name: 'tag_id',
    type: 'varchar',
  })
  tagId: string;

  @Column({
    name: 'asset_type',
    type: 'varchar',
  })
  assetType: AssetType;

  @Column({
    name: 'asset_id',
    type: 'varchar',
  })
  assetId: string;
}

================================================================================

entities/assets/asset-marketplace-tag.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'asset_marketplace_tags' })
export class AssetsMarketPlaceTagEntity extends BaseEntity {
  @Column({
    name: 'asset_type',
    type: 'varchar',
  })
  assetType: AssetType;

  @Column()
  name: string;

  @Column({
    nullable: true,
  })
  color?: string;

  @Column()
  _pinyin: string;
}

================================================================================

entities/assets/asset-tag-definitions.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'asset_tags' })
export class AssetsTagEntity extends BaseEntity {
  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column()
  name: string;

  @Column({
    nullable: true,
  })
  color?: string;

  @Column()
  _pinyin: string;
}

================================================================================

entities/assets/asset-tag-relations.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'asset_tag_relations' })
export class AssetsTagRelationsEntity extends BaseEntity {
  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'tag_id',
    type: 'varchar',
  })
  tagId: string;

  @Column({
    name: 'asset_type',
    type: 'varchar',
  })
  assetType: AssetType;

  @Column({
    name: 'asset_id',
    type: 'varchar',
  })
  assetId: string;
}

================================================================================

entities/assets/base-asset.ts:
--------------------------------------------------------------------------------
import { AssetType, I18nValue } from '@inf-monkeys/monkeys';
import { AfterLoad, Column } from 'typeorm';
import { BaseEntity } from '../base/base';

export enum AssetPublishPolicy {
  authorize = 'authorize',
  clone = 'clone',
  createNew = 'createNew',
}

export class AssetPublishConfig {
  policy: AssetPublishPolicy;
  extraAssetData: BaseAssetEntity;
}

export class BaseAssetEntity extends BaseEntity {
  assetType: AssetType;
  public getAssetId(): string {
    return this.id;
  }

  @Column({
    name: 'team_id',
    nullable: true,
  })
  teamId: string;

  @Column({
    name: 'creator_user_id',
    nullable: true,
  })
  creatorUserId: string;

  @Column({
    nullable: true,
    name: 'icon_url',
  })
  iconUrl?: string;

  @Column({
    name: 'display_name',
    type: 'varchar',
  })
  displayName: string | I18nValue;

  @Column({
    nullable: true,
    type: 'varchar',
  })
  description?: string | I18nValue;

  @Column({
    name: 'is_preset',
    default: false,
  })
  isPreset?: boolean;

  @Column({
    name: 'is_published',
    default: false,
    comment: '此资产是否被发布',
  })
  isPublished?: boolean;

  @Column({
    name: 'publish_config',
    type: 'simple-json',
    nullable: true,
  })
  publishConfig?: AssetPublishConfig;

  @AfterLoad()
  afterLoad?() {
    try {
      this.displayName = JSON.parse(this.displayName as string);
    } catch (error) {}

    try {
      this.description = JSON.parse(this.description as string);
    } catch (error) {}
  }

  getDisplayNameStr(defaultLocale = 'en-US') {
    if (typeof this.displayName === 'string') {
      return this.displayName;
    } else if (typeof this.displayName === 'object' && this.displayName !== null) {
      return this.displayName[defaultLocale] || this.displayName['en-US'] || this.displayName[Object.keys(this.displayName)[0]];
    } else {
      return '';
    }
  }
}

================================================================================

entities/assets/canvas/canvas.ts:
--------------------------------------------------------------------------------
import { CanvasApplication } from '@/common/typings/canvas';
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseAssetEntity } from '../base-asset';

@Entity({ name: 'canvas_applications' })
export class CanvasApplicationEntity extends BaseAssetEntity {
  assetType: AssetType = 'canvas';

  @Column({
    name: 'app_name',
    type: 'varchar',
  })
  appName: CanvasApplication['appName'];

  @Column({
    name: 'creator_user_id',
    type: 'varchar',
  })
  creatorUserId: string;

  @Column({
    name: 'team_id',
    type: 'varchar',
  })
  teamId: string;
}

================================================================================

entities/assets/knowledge-base/knowledge-base-sql.entity.ts:
--------------------------------------------------------------------------------
import { BaseAssetEntity } from '@/database/entities/assets/base-asset';
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';

export enum SqlKnowledgeBaseCreateType {
  builtIn = 'builtIn',
  external = 'external',
}

export enum ExternalSqlDatabaseType {
  mysql = 'mysql',
  postgres = 'postgres',
}

export interface ExternalSqlDatabaseConnectionOptions {
  host: string;
  port: number;
  username: string;
  password: string;
  database: string;
  schema?: string;
}

export interface CreateSqlKnowledgeBaseParams {
  createType: SqlKnowledgeBaseCreateType;
  externalDatabaseType?: ExternalSqlDatabaseType;
  externalDatabaseConnectionOptions?: ExternalSqlDatabaseConnectionOptions;
  displayName?: string;
  description?: string;
  iconUrl?: string;
}

@Entity({ name: 'knowledge_bases_sql' })
export class SqlKnowLedgeBaseEntity extends BaseAssetEntity {
  assetType: AssetType = 'sql-knowledge-base';

  @Column({})
  uuid: string;

  @Column({
    type: 'varchar',
    length: 255,
    name: 'create_type',
    default: SqlKnowledgeBaseCreateType.builtIn,
  })
  createType: SqlKnowledgeBaseCreateType;
}

================================================================================

entities/assets/knowledge-base/knowledge-base.entity.ts:
--------------------------------------------------------------------------------
import { BaseAssetEntity } from '@/database/entities/assets/base-asset';
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';

export enum KnowledgeBaseRetrievalMode {
  VectorSearch = 'vector-search',
  FullTextSearch = 'fulltext-search',
}

export interface KnowledgeBaseRetrievalSettings {
  mode: KnowledgeBaseRetrievalMode;
  topK: number;
  scoreThreshHold?: number;

  // Sometime, you may want to filter the document by metadata before retrieval.
  // For example: See you have serveral documents about different company's annual report, we user ask a question about a specific company,
  // you may want to filter the documents by company name before retrieval.
  enabledMetadataFilter?: boolean;
  metadataFilterKey?: string;
}

@Entity({ name: 'knowledge_bases' })
export class KnowLedgeBaseEntity extends BaseAssetEntity {
  assetType: AssetType = 'knowledge-base';

  @Column({})
  uuid: string;

  @Column({
    name: 'embedding_model',
  })
  embeddingModel: string;

  @Column()
  dimension: number;

  @Column({
    name: 'retrieval_settings',
    nullable: true,
    type: 'simple-json',
  })
  retrievalSettings: KnowledgeBaseRetrievalSettings;

  public getRetrievalSettings(): KnowledgeBaseRetrievalSettings {
    return (
      this.retrievalSettings || {
        mode: KnowledgeBaseRetrievalMode.VectorSearch,
        topK: 3,
      }
    );
  }
}

================================================================================

entities/assets/media/media-file.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseAssetEntity } from '../base-asset';

export enum MediaSource {
  UPLOAD = 1,
  AIGC_INFER = 2,
  AUTO_GENERATE = 3,
}

export type MediaType = 'image' | 'text' | 'video' | 'audio';

export type MediaImageParams = {
  width: number;
  height: number;
} & Record<string, unknown>;

@Entity({ name: 'media_files' })
export class MediaFileEntity extends BaseAssetEntity {
  assetType: AssetType = 'media-file';

  @Column({
    type: 'varchar',
  })
  type: MediaType;

  @Column()
  url: string;

  @Column({
    type: 'varchar',
  })
  source: MediaSource;

  @Column({
    nullable: true,
  })
  size?: number;

  @Column({
    type: 'simple-json',
    nullable: true,
  })
  params?: any;

  @Column({
    nullable: true,
    type: 'varchar',
  })
  md5?: string;
}

================================================================================

entities/assets/model/comfyui-model/comfyui-model-server-relation.entity.ts:
--------------------------------------------------------------------------------
import { BaseEntity } from '@/database/entities/base/base';
import { ComfyuiServerEntity } from '@/database/entities/comfyui/comfyui-server.entity';
import { Column, Entity, ManyToOne } from 'typeorm';
import { ComfyuiModelEntity } from './comfyui-model.entity';

@Entity({ name: 'comfyui_model_server_relations' })
export class ComfyuiModelServerRelationEntity extends BaseEntity {
  @ManyToOne(() => ComfyuiModelEntity, (model) => model.serverRelations, { onDelete: 'CASCADE', onUpdate: 'CASCADE' })
  model: ComfyuiModelEntity;

  @ManyToOne(() => ComfyuiServerEntity, (server) => server.modelRelations, { onDelete: 'CASCADE', onUpdate: 'CASCADE' })
  server: ComfyuiServerEntity;

  @Column({
    name: 'team_id',
    type: 'varchar',
    length: 255,
    nullable: true,
  })
  teamId: string | null;

  @Column({
    name: 'path',
    type: 'varchar',
    length: 255,
  })
  path: string;

  @Column({
    name: 'filename',
    type: 'varchar',
    length: 255,
  })
  filename: string;
}

================================================================================

entities/assets/model/comfyui-model/comfyui-model-type.entity.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseAssetEntity } from '../../base-asset';

export type CreateComfyuiModelTypeParams = Pick<ComfyuiModelTypeEntity, 'displayName' | 'description' | 'name' | 'path'>;

export type UpdateComfyuiModelTypeParams = Partial<Pick<ComfyuiModelTypeEntity, 'displayName' | 'description' | 'name' | 'path'>>;

export type GetComfyuiModelTypeQuery = Partial<Pick<ComfyuiModelTypeEntity, 'name' | 'path'>>;

@Entity({ name: 'comfyui_model_type' })
export class ComfyuiModelTypeEntity extends BaseAssetEntity {
  assetType: AssetType = 'comfyui-model-type';

  @Column({
    name: 'name',
    type: 'varchar',
    length: 255,
  })
  name: string;

  @Column({
    name: 'path',
    type: 'varchar',
    length: 255,
  })
  path: string;
}

================================================================================

entities/assets/model/comfyui-model/comfyui-model.entity.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity, OneToMany } from 'typeorm';
import { BaseAssetEntity } from '../../base-asset';
import { ComfyuiModelServerRelationEntity } from './comfyui-model-server-relation.entity';

export type CreateComfyuiModelParams = Pick<ComfyuiModelEntity, 'sha256'> & Partial<Pick<ComfyuiModelEntity, 'id' | 'displayName' | 'description' | 'serverRelations'>>;

export type UpdateComfyuiModelParams = Partial<Pick<ComfyuiModelEntity, 'displayName' | 'description' | 'iconUrl'>>;

@Entity({ name: 'comfyui_model' })
export class ComfyuiModelEntity extends BaseAssetEntity {
  assetType: AssetType = 'comfyui-model';

  @Column({
    name: 'sha256',
    type: 'varchar',
    length: 255,
  })
  sha256: string;

  @OneToMany(() => ComfyuiModelServerRelationEntity, (servers) => servers.model)
  serverRelations?: ComfyuiModelServerRelationEntity[];
}

================================================================================

entities/assets/model/llm-channel/llm-channel.entity.ts:
--------------------------------------------------------------------------------
import { BaseAssetEntity } from '@/database/entities/assets/base-asset';
import { AssetType, ToolProperty } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';

@Entity({ name: 'llm_channels' })
export class LlmChannelEntity extends BaseAssetEntity {
  assetType: AssetType = 'llm-channel';

  @Column({
    name: 'properites',
    type: 'simple-json',
  })
  properites: ToolProperty[];
}

================================================================================

entities/assets/model/llm-model/llm-model.ts:
--------------------------------------------------------------------------------
import { BaseAssetEntity } from '@/database/entities/assets/base-asset';
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';

/** OneAPI Model Mapping, for example
 
{
  "66507989ff7d6e1d8b3f2517_moonshot-v1-8k": "moonshot-v1-8k",
  "66507989ff7d6e1d8b3f2517_moonshot-v1-32k": "moonshot-v1-32k",
  "66507989ff7d6e1d8b3f2517_moonshot-v1-128k": "moonshot-v1-128k"
}
 */

export interface LlmOneapiModel {
  [key: string]: string;
}

@Entity({ name: 'llm_models' })
export class LlmModelEntity extends BaseAssetEntity {
  assetType: AssetType = 'llm-model';

  @Column({ type: 'integer', nullable: true, comment: 'LLM Channel Type', name: 'oneapi_channel_type' })
  channelType: number;

  @Column({
    type: 'simple-json',
    nullable: true,
    name: 'oneapi_channel_id',
  })
  channelId: number;

  @Column({
    type: 'simple-json',
    nullable: true,
    name: 'oneapi_models',
  })
  models: LlmOneapiModel;
}

export type UpdateLlmModelParams = Partial<Pick<LlmModelEntity, 'displayName' | 'description' | 'iconUrl'>>;

================================================================================

entities/assets/model/sd-model/sd-model.ts:
--------------------------------------------------------------------------------
import { BaseAssetEntity } from '@/database/entities/assets/base-asset';
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';

export enum SdWorkProcessStatus {
  PENDING = 0,
  CONVERTING = 1,
  FINISHED = 2,
  FAIL = 3,
}

export type SdModelType = 'Checkpoint' | 'Lora' | 'Embedding' | 'VAE';

export interface XYZTestResult {
  error?: string;
  x: { name: string; value: string[] };
  y: { name: string; value: string[] };
  items: { x: string; y: string; href: string; prompt: string }[][];
}

@Entity({ name: 'sd_models' })
export class SdModelEntity extends BaseAssetEntity {
  assetType: AssetType = 'sd-model';

  @Column({
    type: 'varchar',
  })
  status: SdWorkProcessStatus;

  @Column({
    nullable: true,
  })
  progress: number;

  @Column()
  md5: string;

  @Column({
    name: 'model_id',
  })
  modelId: string;

  @Column()
  keywords: string;

  @Column({
    type: 'simple-json',
  })
  images: string[];

  @Column({
    type: 'simple-json',
  })
  params: Record<string, any>;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  type?: SdModelType;

  @Column({
    type: 'varchar',
    name: 'base_model',
  })
  baseModel: 'SD 1' | 'SD 2' | 'SDXL';

  @Column({
    name: 'model_format',
    nullable: true,
  })
  modelFormat?: 'ckpt' | 'safetensors' = 'ckpt';

  @Column({
    name: 'disable_text_to_image',
    nullable: true,
  })
  disableTextToImage?: boolean = false;

  @Column({
    name: 'disable_image_to_image',
    nullable: true,
  })
  disableImageToImage?: boolean = false;

  @Column({
    name: 'disable_fine_tune',
    nullable: true,
  })
  disableFineTune?: boolean = false;

  @Column({
    name: 'output_models',
    nullable: true,
    type: 'simple-json',
  })
  outputModels?: string[];

  @Column({
    name: 'output_samples',
    nullable: true,
    type: 'simple-json',
  })
  outputSamples?: string[];

  @Column({
    name: 'output_logs',
    nullable: true,
    type: 'simple-json',
  })
  outputLogs?: [];

  @Column({
    name: 'output_xyz_test',
    nullable: true,
    type: 'simple-json',
  })
  outputXYZTest?: XYZTestResult;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  version?: string;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'civitai_url',
  })
  civitaiUrl?: string;

  @Column({
    nullable: true,
    type: 'simple-json',
  })
  tags: string[];
}

================================================================================

entities/base/base.ts:
--------------------------------------------------------------------------------
import { TimestampTransformer } from '@/database/transformers/timestamp.transformer';
import { Column, CreateDateColumn, PrimaryColumn, UpdateDateColumn } from 'typeorm';

export class BaseEntity {
  @PrimaryColumn({
    type: 'varchar',
    length: 128,
  })
  id: string;

  @CreateDateColumn({
    name: 'created_timestamp',
    type: 'timestamp',
    transformer: TimestampTransformer,
  })
  createdTimestamp: number;

  @UpdateDateColumn({
    name: 'updated_timestamp',
    type: 'timestamp',
    transformer: TimestampTransformer,
  })
  updatedTimestamp: number;

  @Column({ default: false, name: 'is_deleted' })
  isDeleted?: boolean;
}

================================================================================

entities/comfyui/comfyui-server.entity.ts:
--------------------------------------------------------------------------------
import { Column, Entity, OneToMany } from 'typeorm';
import { ComfyuiModelServerRelationEntity } from '../assets/model/comfyui-model/comfyui-model-server-relation.entity';
import { BaseEntity } from '../base/base';

export enum ComfyuiServerStatus {
  Unkonwn = 'UNKOWN',
  UP = 'UP',
  DOWN = 'DOWN',
}

@Entity({ name: 'comfyui_servers' })
export class ComfyuiServerEntity extends BaseEntity {
  @Column({
    name: 'team_id',
    type: 'varchar',
    length: 1024,
    nullable: true,
  })
  teamId?: string;

  @Column({
    name: 'creator_user_id',
    type: 'varchar',
    length: 1024,
    nullable: true,
  })
  creatorUserId?: string;

  @Column({
    name: 'address',
    type: 'varchar',
    length: 1024,
  })
  address: string;

  @Column({
    name: 'status',
    type: 'varchar',
    length: 64,
    default: ComfyuiServerStatus.Unkonwn,
  })
  status: ComfyuiServerStatus;

  @Column({
    name: 'description',
    type: 'varchar',
    length: 1024,
  })
  description: string;

  @Column({
    name: 'is_default',
    type: 'boolean',
    default: false,
  })
  isDefault: boolean;

  @OneToMany(() => ComfyuiModelServerRelationEntity, (models) => models.server)
  modelRelations?: ComfyuiModelServerRelationEntity[];
}

================================================================================

entities/comfyui/comfyui-workflow.entity.ts:
--------------------------------------------------------------------------------
import { ComfyuiPrompt, ComfyuiWorkflow } from '@/common/typings/comfyui';
import { ToolProperty } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseAssetEntity } from '../assets/base-asset';

export enum ComfyuiWorkflowSourceType {
  Image = 'image',
  Json = 'json',
  Comfyfile = 'comfyfile',
}

export interface ComfyUIWorkflowAddtionalModel {
  name: string;
  url: string;
  dest: string;
}

export interface ComfyUIWorkflowAddtionalNode {
  name: string;
  url: string;
}

@Entity({ name: 'comfyui_workflows' })
export class ComfyuiWorkflowEntity extends BaseAssetEntity {
  @Column({
    name: 'workflow_type',
    type: 'varchar',
    length: 255,
  })
  workflowType: ComfyuiWorkflowSourceType;

  @Column({
    name: 'originla_data',
    type: 'simple-json',
    comment: 'Original Data',
  })
  originalData: { [x: string]: any };

  @Column({
    name: 'workflow',
    type: 'simple-json',
    nullable: true,
  })
  workflow?: ComfyuiWorkflow;

  @Column({
    name: 'prompt',
    type: 'simple-json',
    nullable: true,
  })
  prompt?: ComfyuiPrompt;

  @Column({
    name: 'tool_input',
    type: 'simple-json',
  })
  toolInput: ToolProperty[];

  @Column({
    name: 'tool_output',
    type: 'simple-json',
  })
  toolOutput: ToolProperty[];

  @Column({
    name: 'additional_model_list',
    type: 'simple-json',
    nullable: true,
  })
  additionalModelList?: ComfyUIWorkflowAddtionalModel[];

  @Column({
    name: 'additional_node_list',
    type: 'simple-json',
    nullable: true,
  })
  additionalNodeList?: ComfyUIWorkflowAddtionalNode[];
}

================================================================================

entities/config/theme.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'themes' })
export class ThemeEntity extends BaseEntity {
  @Column({ nullable: true })
  teamId?: string;

  @Column()
  name: string; // 主题名称

  @Column({ nullable: true })
  primaryColor?: string;

  @Column({ nullable: true })
  backgroundColor?: string;

  @Column({ nullable: true })
  secondaryBackgroundColor?: string;

  @Column({ nullable: true })
  isPublic?: boolean;
}

================================================================================

entities/conversation-app/conversation-app.entity.ts:
--------------------------------------------------------------------------------
import { AssetType } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseAssetEntity } from '../assets/base-asset';

export interface CreateConversationAppParams {
  customModelName?: string;
  displayName?: string;
  description?: string;
  iconUrl?: string;
  model: string;
  systemPrompt?: string;
  knowledgeBase?: string;
  sqlKnowledgeBase?: string;
  tools?: string[];
  temperature?: number;
  presence_penalty?: number;
  frequency_penalty?: number;
}

export interface UpdateConversationAppParams {
  customModelName?: string;
  displayName?: string;
  description?: string;
  iconUrl?: string;
  model?: string;
  systemPrompt?: string;
  knowledgeBase?: string;
  sqlKnowledgeBase?: string;
  tools?: string[];
  temperature?: number;
  presence_penalty?: number;
  frequency_penalty?: number;
}

@Entity({ name: 'conversation_apps' })
export class ConversationAppEntity extends BaseAssetEntity {
  assetType: AssetType = 'conversation-app';

  @Column({
    name: 'custom_model_name',
    type: 'varchar',
    nullable: true,
  })
  customModelName?: string;

  @Column({
    name: 'model',
    type: 'varchar',
  })
  model: string;

  @Column({
    name: 'system_prompt',
    type: 'text',
    nullable: true,
  })
  systemPrompt?: string;

  @Column({
    name: 'knowledge_base',
    type: 'varchar',
    nullable: true,
  })
  knowledgeBase?: string;

  @Column({
    name: 'sql_knowledge_base',
    type: 'varchar',
    nullable: true,
  })
  sqlKnowledgeBase?: string;

  @Column({
    name: 'tools',
    type: 'simple-json',
    nullable: true,
  })
  tools?: string[];

  @Column({
    name: 'temperature',
    type: 'float',
    nullable: true,
    default: 0.7,
  })
  temperature?: number;

  @Column({
    name: 'presence_penalty',
    type: 'float',
    nullable: true,
    default: 0.5,
  })
  presence_penalty?: number;

  @Column({
    name: 'frequency_penalty',
    type: 'float',
    nullable: true,
    default: 0.5,
  })
  frequency_penalty?: number;
}

================================================================================

entities/conversation-app/conversation-executions.entity.ts:
--------------------------------------------------------------------------------
import { ConversationStatusEnum } from '@/common/dto/status.enum';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'conversation_executions' })
export class ConversationExecutionEntity extends BaseEntity {
  @Column({
    name: 'app_id',
  })
  appId: string;

  @Column({
    name: 'user_id',
  })
  userId: string;

  @Column({
    name: 'status',
    nullable: true,
    type: 'varchar',
    length: 255,
  })
  status: ConversationStatusEnum;

  @Column({
    name: 'takes',
    nullable: true,
  })
  takes: number;
}

================================================================================

entities/identity/team-invites.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export enum TeamInviteLinkOutdateType {
  SEVEN_DAYS = 1,
  NEVER = 2,
}

export enum TeamInviteType {
  INDIVIDUAL = 1,
  PUBLIC = 2,
}

export enum TeamInviteStatus {
  EFFECTIVE = 1,
  ACCEPTED = 2,
  DISABLED = 3,
}

@Entity({ name: 'team_invites' })
export class TeamInvitesRequestsEntity extends BaseEntity {
  @Column({
    name: 'inviter_user_id',
  })
  inviterUserId: string;

  @Column({
    name: 'target_user_id',
    nullable: true,
  })
  targetUserId?: string;

  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'type',
    type: 'int',
  })
  type: TeamInviteType; // 若为 PUBLIC 则无人数限制

  @Column({
    name: 'outdate_timestamp',
  })
  outdateTimestamp: number;

  @Column({
    name: 'status',
    type: 'int',
  })
  status: TeamInviteStatus;

  @Column({
    name: 'accepted_user_ids',
    type: 'simple-json',
  })
  acceptedUserIds: string[];

  @Column({
    name: 'remark',
    type: 'text',
    nullable: true,
  })
  remark?: string;
}

================================================================================

entities/identity/team-join-request.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export enum TeamJoinRequestStatus {
  PENDING = 'PENDING',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED',
}

@Entity({ name: 'team_join_requests' })
export class TeamJoinRequestsEntity extends BaseEntity {
  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'user_id',
  })
  userId: string;

  @Column({
    name: 'status',
    type: 'varchar',
  })
  status: TeamJoinRequestStatus;
}

================================================================================

entities/identity/team.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export interface CustomTheme {
  enableTeamLogo?: boolean;
  primaryColor?: string;
}

@Entity({ name: 'teams' })
export class TeamEntity extends BaseEntity {
  @Column()
  name: string;

  @Column({
    nullable: true,
  })
  description?: string;

  @Column({
    name: 'icon_url',
    nullable: true,
  })
  iconUrl?: string;

  @Column({
    name: 'darkmode_icon_url',
    nullable: true,
  })
  darkmodeIconUrl?: string;

  @Column({
    name: 'owner_user_id',
  })
  ownerUserId: string;

  @Column({
    name: 'is_builtin',
    default: false,
  })
  isBuiltIn?: boolean; // 只有默认团队会赠送猿力值

  @Column({
    name: 'is_public',
    default: false,
    type: 'boolean',
  })
  isPublic?: boolean;

  @Column({
    name: 'workflow_task_name_prefix',
    type: 'varchar',
    nullable: true,
  })
  workflowTaskNamePrefix?: string;

  @Column({
    name: 'custom_theme',
    nullable: true,
    type: 'simple-json',
  })
  customTheme?: CustomTheme;

  @Column({
    name: 'enable_join_request',
    nullable: true,
    default: false,
  })
  enableJoinRequest?: boolean;
}

================================================================================

entities/identity/user-team-relationship.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'team_members' })
export class TeamMembersEntity extends BaseEntity {
  @Column({
    name: 'user_id',
  })
  userId: string;

  @Column({
    name: 'team_id',
  })
  teamId: string;
}

================================================================================

entities/identity/user.ts:
--------------------------------------------------------------------------------
import { AuthMethod } from '@/common/config';
import { Column, Entity, Index } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'users' })
@Index(['phone'])
@Index(['email'])
@Index(['externalId'])
export class UserEntity extends BaseEntity {
  @Column({
    type: 'varchar',
    nullable: true,
  })
  name: string;

  @Column({
    type: 'varchar',
  })
  photo: string;

  @Column({
    name: 'nickname',
    nullable: true,
  })
  nickname?: string;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  phone?: string;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  email?: string;

  @Column({
    type: 'varchar',
    nullable: true,
  })
  password?: string;

  @Column({
    type: 'bigint',
    nullable: true,
    name: 'last_login_at',
  })
  lastLoginAt?: number;

  @Column({
    type: 'integer',
    nullable: true,
    name: 'logins_count',
  })
  loginsCount?: number;

  @Column({
    type: 'boolean',
    nullable: true,
  })
  verified?: boolean;

  @Column({
    type: 'boolean',
    nullable: true,
    name: 'is_blocked',
  })
  isBlocked?: boolean;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'external_id',
  })
  externalId?: string;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'last_auth_method',
  })
  lastAuthMethod?: AuthMethod;
}

================================================================================

entities/observability/team-observability.ts:
--------------------------------------------------------------------------------

================================================================================

entities/observability/workflow-observability.ts:
--------------------------------------------------------------------------------
import { ObservabilityPlatform, ObservabilityPlatformConfig } from '@/modules/workflow/interfaces/observability';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'workflow_observability' })
export class WorkflowObservabilityEntity extends BaseEntity {
  @Column({ name: 'workflow_id' })
  workflowId: string;

  @Column({ name: 'team_id' })
  teamId: string;

  @Column({ name: 'name', nullable: true })
  name?: string;

  @Column({ name: 'platform' })
  platform: ObservabilityPlatform;

  @Column({ name: 'platform_config', type: 'simple-json' })
  platformConfig: ObservabilityPlatformConfig;
}

================================================================================

entities/oneapi/oneapi-user.entity.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export interface CustomTheme {
  enableTeamLogo?: boolean;
  primaryColor?: string;
}

@Entity({ name: 'oneapi_users' })
export class OneApiUsersEntity extends BaseEntity {
  @Column({
    type: 'varchar',
    nullable: true,
    name: 'team_id',
  })
  teamId: string;

  @Column({
    type: 'integer',
    nullable: true,
    name: 'user_id',
  })
  userId: number;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'user_token',
  })
  userToken?: string;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'api_key',
  })
  apiKey?: string;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'username',
  })
  username?: string;

  @Column({
    type: 'varchar',
    nullable: true,
    name: 'password',
  })
  password?: string;
}

================================================================================

entities/system/system-configuration.entity.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'system_configurations' })
export class SystemConfigurationEntity extends BaseEntity {
  @Column({
    name: 'key',
  })
  key: string;

  @Column({
    name: 'value',
  })
  value: string;
}

================================================================================

entities/tools/tools-credential-type.entity.ts:
--------------------------------------------------------------------------------
import { CredentialAuthType } from '@/common/typings/tools';
import { ToolProperty } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'tools_credential_types' })
export class ToolsCredentialTypeEntity extends BaseEntity {
  @Column()
  name: string;

  @Column()
  namespace: string;

  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    type: 'varchar',
  })
  type: CredentialAuthType;

  @Column({
    nullable: true,
  })
  description?: string;

  @Column({
    nullable: true,
    name: 'icon_url',
  })
  iconUrl?: string;

  @Column({
    type: 'simple-json',
  })
  properties: ToolProperty[];
}

================================================================================

entities/tools/tools-credential.entity.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

/**
 * 密钥数据表
 */
@Entity({ name: 'tools_credentials' })
export class ToolsCredentialEntity extends BaseEntity {
  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    name: 'creator_user_id',
  })
  creatorUserId: string;

  @Column()
  type: string;

  @Column({
    name: 'encrypted_data',
    type: 'text',
  })
  encryptedData: string;
}

================================================================================

entities/tools/tools-server.entity.ts:
--------------------------------------------------------------------------------
import { ApiType, AuthConfig, SchemaVersion, ToolRateLimiterConfig, TriggerEndpointConfig } from '@/common/typings/tools';
import { Column, Entity } from 'typeorm';
import url from 'url';
import { BaseEntity } from '../base/base';

export interface INodeCredentialDescription {
  name: string;
  required?: boolean;
}

export class ApiConfig {
  @Column({
    name: 'api_config',
  })
  type: ApiType;

  @Column({
    name: 'api_url',
  })
  url: string;
}

export const SYSTEM_NAMESPACE = 'system';
export const API_NAMESPACE = 'api';

export enum HealthCheckStatus {
  UP = 'UP',
  DOWN = 'DOWN',
}

@Entity({ name: 'tools_server' })
export class ToolsServerEntity extends BaseEntity {
  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    name: 'base_url',
  })
  baseUrl: string;

  @Column({
    name: 'manifest_url',
    default: SchemaVersion.v1,
  })
  manifestUrl: string;

  @Column({
    name: 'schema_version',
    default: SchemaVersion.v1,
  })
  schemaVersion: SchemaVersion;

  @Column({
    name: 'namespace',
    unique: true,
  })
  namespace: string;

  @Column({
    type: 'simple-json',
  })
  auth: AuthConfig;

  @Column({
    type: 'simple-json',
  })
  api: ApiConfig;

  @Column({
    type: 'simple-json',
    name: 'trigger_endpoints',
    nullable: true,
  })
  triggerEndpoints: TriggerEndpointConfig[];

  @Column({
    type: 'simple-json',
    name: 'rate_limiter',
    nullable: true,
  })
  rateLimiter?: ToolRateLimiterConfig;

  @Column({
    name: 'health_check',
    nullable: true,
  })
  heatlhCheck?: string;

  @Column({
    name: 'health_check_status',
    nullable: true,
  })
  healthCheckStatus?: HealthCheckStatus;

  @Column({
    name: 'log_endpoint',
    nullable: true,
  })
  logEndpoint?: string;

  @Column({
    name: 'ras_public_key',
    nullable: true,
    type: 'varchar',
    length: 4096,
  })
  rasPublicKey?: string;

  public getSpecUrl() {
    const {
      manifestUrl,
      api: { url: specUrl },
    } = this;
    let realSpecUrl = specUrl;
    if (!realSpecUrl.startsWith('http://') && !realSpecUrl.startsWith('https://')) {
      const parsedUrl = url.parse(manifestUrl);
      const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}`;
      realSpecUrl = url.resolve(baseUrl, realSpecUrl);
    }
    return realSpecUrl;
  }

  public getHealthCheckUrl() {
    const { manifestUrl, heatlhCheck } = this;
    let realHealthCheckUrl = heatlhCheck;
    if (!realHealthCheckUrl.startsWith('http://') && !realHealthCheckUrl.startsWith('https://')) {
      const parsedUrl = url.parse(manifestUrl);
      const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}`;
      realHealthCheckUrl = url.resolve(baseUrl, realHealthCheckUrl);
    }
    return realHealthCheckUrl;
  }
}

================================================================================

entities/tools/tools-trigger-types.ts:
--------------------------------------------------------------------------------
import { ToolProperty } from '@inf-monkeys/monkeys';
import { Column, Entity, Index } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'tools_trigger_types' })
@Index(['type'])
export class ToolsTriggerTypesEntity extends BaseEntity {
  @Column({
    type: 'varchar',
  })
  type: string;

  @Column()
  namespace: string;

  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    nullable: true,
  })
  description?: string;

  @Column({
    nullable: true,
  })
  icon?: string;

  @Column({
    type: 'simple-json',
    nullable: true,
  })
  properties: ToolProperty[];

  @Column({
    type: 'simple-json',
    nullable: true,
    name: 'workflow_inputs',
  })
  workflowInputs: ToolProperty[];
}

================================================================================

entities/tools/tools.entity.ts:
--------------------------------------------------------------------------------
import { I18nValue, ToolCredentialItem, ToolExtraInfo, ToolProperty, ToolRuleItem, ToolType } from '@inf-monkeys/monkeys';
import { AfterLoad, Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'tools' })
export class ToolsEntity extends BaseEntity {
  @Column({
    nullable: true,
    name: 'creator_user_id',
  })
  creatorUserId?: string;

  @Column({
    nullable: true,
  })
  teamId?: string;

  @Column({
    nullable: true,
  })
  public?: boolean;

  @Column({
    default: ToolType.SIMPLE,
    type: 'varchar',
  })
  type: ToolType;

  @Column()
  namespace: string;

  @Column()
  name: string;

  @Column({
    nullable: true,
    type: 'simple-json',
  })
  credentials?: ToolCredentialItem[];

  @Column({
    name: 'display_name',
    type: 'varchar',
  })
  displayName: string | I18nValue;

  @Column({
    nullable: true,
    type: 'varchar',
  })
  description?: string | I18nValue;

  @Column({
    nullable: true,
    type: 'simple-json',
  })
  categories?: string[];

  @Column({
    nullable: true,
  })
  icon?: string;

  @Column({
    nullable: true,
    comment: '表单配置',
    type: 'simple-json',
  })
  input: ToolProperty[];

  @Column({
    nullable: true,
    comment: '输出数据',
    type: 'simple-json',
  })
  output: ToolProperty[];

  @Column({
    type: 'simple-json',
    nullable: true,
  })
  rules?: ToolRuleItem[];

  @Column({
    type: 'simple-json',
    nullable: true,
  })
  extra?: ToolExtraInfo;

  @AfterLoad()
  afterLoad?() {
    try {
      this.displayName = JSON.parse(this.displayName as string);
    } catch (error) {}

    try {
      this.description = JSON.parse(this.description as string);
    } catch (error) {}
  }
}

================================================================================

entities/workflow/workflow-chat-session.ts:
--------------------------------------------------------------------------------
import { ChatCompletionMessageParam } from 'openai/resources';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'workflow_chat_sessions' })
export class WorkflowChatSessionEntity extends BaseEntity {
  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'creator_user_id',
  })
  creatorUserId: string;

  @Column({
    name: 'workflow_id',
  })
  workflowId: string;

  @Column({
    name: 'messages',
    nullable: true,
    type: 'simple-json',
  })
  messages?: Array<ChatCompletionMessageParam>;
}

================================================================================

entities/workflow/workflow-execution.ts:
--------------------------------------------------------------------------------
import { WorkflowStatusEnum } from '@/common/dto/status.enum';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';
import { WorkflowTriggerType } from './workflow-trigger';

@Entity({ name: 'workflow_execution' })
export class WorkflowExecutionEntity extends BaseEntity {
  @Column({
    name: 'workflow_id',
  })
  workflowId: string;

  @Column({
    name: 'workflow_version',
  })
  workflowVersion: number;

  @Column({
    name: 'workflow_instance_id',
  })
  workflowInstanceId: string;

  @Column({
    name: 'user_id',
  })
  userId: string;

  @Column({
    name: 'trigger_type',
    type: 'varchar',
  })
  triggerType: WorkflowTriggerType;

  @Column({
    name: 'chat_session_id',
    nullable: true,
  })
  chatSessionId?: string;

  @Column({
    name: 'group',
    nullable: true,
  })
  group?: string;

  @Column({
    name: 'status',
    nullable: true,
    type: 'varchar',
    length: 255,
  })
  status: WorkflowStatusEnum;

  @Column({
    name: 'takes',
    nullable: true,
  })
  takes: number;

  @Column({
    name: 'apikey',
    nullable: true,
  })
  apikey: string;
}

================================================================================

entities/workflow/workflow-metadata.ts:
--------------------------------------------------------------------------------
import { AssetType, MonkeyTaskDefTypes, ToolProperty } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseAssetEntity } from '../assets/base-asset';
import { WorkflowTriggerType } from './workflow-trigger';

export enum ValidationIssueType {
  ERROR = 'ERROR',
  WANRING = 'WANRING',
}

export enum ValidationReasonType {
  VALUE_REQUIRED = 'VALUE_REQUIRED',
  INALID_VALUE = 'INALID_VALUE',
  VALUE_TYPE_NOT_MATCH = 'VALUE_TYPE_NOT_MATCH',
  DO_WHILE_EMPTY_LOOP_OVER = 'DO_WHILE_EMPTY_LOOP_OVER',
  CODE_INVALID_MODULE = 'CODE_INVALID_MODULE',
  REFERENCED_UNKNOWN_TASK = 'REFERENCED_UNKNOWN_TASK',
  MISSING_CREDENTIAL = 'MISSING_CREDENTIAL',
  SUB_WORKFLOW_PARAM_MISSING = 'SUB_WORKFLOW_PARAM_MISSING',
  SUB_WORKFLOW_NAME_MISSING = 'SUB_WORKFLOW_NAME_MISSING',
}

export interface ValidationIssueReson {
  type: ValidationReasonType;
  name: string;
  detailInfomation?: { [x: string]: any };
}

export interface WorkflowValidationIssue {
  taskReferenceName: string;
  issueType: ValidationIssueType;
  detailReason: ValidationIssueReson;
  humanMessage: {
    en: string;
    zh: string;
  };
}

export interface WorkflowTriggerConfig {
  triggerType: WorkflowTriggerType;
  cron?: string;
}

export interface WorkflowOutputValue {
  key: string;
  value: string;
}

export interface WorkflowRateLimiter {
  enabled: boolean;
  windowMs: number;
  max: number;
}

@Entity({ name: 'workflow_metadatas' })
export class WorkflowMetadataEntity extends BaseAssetEntity {
  assetType: AssetType = 'workflow';
  public getAssetId() {
    return this.workflowId;
  }

  @Column({
    name: 'workflow_id',
  })
  workflowId: string;

  @Column()
  version: number;

  /**
   * 工作流是否成功激活，非激活状态的工作流不允许执行
   *
   */
  @Column({
    default: true,
  })
  activated?: boolean;

  @Column({
    default: true,
  })
  validated?: boolean;

  @Column({
    nullable: true,
    comment: 'conductor workflow json 定义',
    type: 'simple-json',
    name: 'tasks',
  })
  tasks: MonkeyTaskDefTypes[];

  @Column({
    comment: 'workflow 变量',
    type: 'simple-json',
    nullable: true,
  })
  variables?: ToolProperty[];

  @Column({
    comment: 'workflow output 配置',
    type: 'simple-json',
    nullable: true,
  })
  output: WorkflowOutputValue[];

  @Column({
    nullable: true,
    comment: 'fork from',
    name: 'fork_from_id',
  })
  forkFromId?: string;

  @Column({
    nullable: true,
    comment: '工作流校验错误/警告',
    type: 'simple-json',
    name: 'validation_issues',
  })
  validationIssues?: WorkflowValidationIssue[];

  @Column({
    nullable: true,
  })
  md5?: string;

  @Column({
    nullable: true,
    default: false,
  })
  hidden?: boolean;

  @Column({
    name: 'rate_limiter',
    type: 'simple-json',
    nullable: true,
  })
  rateLimiter: WorkflowRateLimiter;

  @Column({
    name: 'expose_openai_compatible_interface',
    default: false,
  })
  exposeOpenaiCompatibleInterface: boolean;

  @Column({
    name: 'openai_model_name',
    nullable: true,
  })
  openaiModelName: string;

  @Column({
    name: 'not_authorized',
    nullable: true,
    default: false,
  })
  notAuthorized?: boolean;

  @Column({
    type: 'text',
    name: 'shortcuts_flow',
    nullable: true,
  })
  shortcutsFlow?: string;

  @Column({
    nullable: true,
    default: false,
    type: 'varchar',
  })
  thumbnail?: string;

  public isRateLimitEnabled() {
    return this.rateLimiter?.enabled;
  }
}

================================================================================

entities/workflow/workflow-page-group.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'workflow_page_group' })
export class WorkflowPageGroupEntity extends BaseEntity {
  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    name: 'is_builtin',
    type: 'boolean',
  })
  isBuiltIn: boolean;

  @Column({
    name: 'team_id',
    type: 'varchar',
  })
  teamId: string;

  @Column({
    name: 'page_ids',
    type: 'simple-json',
    nullable: true,
  })
  pageIds: string[];
}

================================================================================

entities/workflow/workflow-page.ts:
--------------------------------------------------------------------------------
import { ToolProperty } from '@inf-monkeys/monkeys';
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export type PagePermission = 'read' | 'write' | 'exec' | 'permission';

export type PageInstanceType = 'process' | 'log' | 'chat' | 'preview' | 'api';

export interface PageInstance {
  name: string;
  icon: string;
  type: PageInstanceType;
  allowedPermissions: PagePermission[];
  customOptionsProperties?: ToolProperty[];
}

@Entity({ name: 'workflow_pages' })
export class WorkflowPageEntity extends BaseEntity {
  @Column({
    name: 'display_name',
  })
  displayName: string;

  @Column({
    type: 'varchar',
  })
  type: PageInstance['type'];

  @Column({
    name: 'workflow_id',
    type: 'varchar',
  })
  workflowId: string;

  @Column({
    name: 'is_builtin',
    type: 'boolean',
  })
  isBuiltIn: boolean;

  @Column({
    name: 'team_id',
    type: 'varchar',
  })
  teamId: string;

  @Column({
    type: 'simple-json',
  })
  permissions: PagePermission[];

  @Column({
    name: 'sort_index',
    type: 'integer',
  })
  sortIndex: number;

  @Column({
    name: 'custom_options',
    type: 'simple-json',
    nullable: true,
  })
  customOptions?: Record<string, any>;

  @Column({
    default: false,
    type: 'boolean',
    nullable: true,
  })
  pinned?: boolean;
}

================================================================================

entities/workflow/workflow-template.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

@Entity({ name: 'workflow_templates' })
export class WorkflowTemplateEntity extends BaseEntity {
  @Column()
  name: string;

  @Column()
  desc?: string;

  @Column()
  logo?: string;

  @Column({
    name: 'team_id',
  })
  teamId: string;

  @Column({
    name: 'workflow_id',
  })
  workflowId: string;

  @Column({
    name: 'workflow_version',
  })
  workflowVersion: number;

  @Column({
    name: 'creator_user_id',
  })
  creatorUserId: string;

  @Column({
    name: 'fetch_count',
  })
  fetchCount: number;

  @Column({
    type: 'simple-json',
    name: 'assets_policy',
  })
  assetsPolicy: { [x: string]: any };
}

================================================================================

entities/workflow/workflow-trigger.ts:
--------------------------------------------------------------------------------
import { Column, Entity } from 'typeorm';
import { BaseEntity } from '../base/base';

export enum WorkflowTriggerType {
  // 手动
  MANUALLY = 'MANUAL',
  // 定时
  SCHEDULER = 'SCHEDULER',
  // Webhook
  WEBHOOK = 'WEBHOOK',
  // API
  API = 'API',
}

export enum WorkflowTriggerMethod {
  GET = 'GET',
  POST = 'POST',
  PUT = 'PUT',
  PATCH = 'PATCH',
  DELETE = 'DELETE',
  OPTIONS = 'OPTIONS',
  HEAD = 'HEAD',
}

export enum WorkflowTriggerAuthType {
  NONE = 'NONE',
  BASIC = 'BASIC',
  CUSTOM_HEADER = 'CUSTOM_HEADER',
}

export enum WebhookTriggerResponseUntil {
  WORKFLOW_STARTED = 'WORKFLOW_STARTED',
  WORKFLOW_COMPLETED_OR_FINISHED = 'WORKFLOW_COMPLETED_OR_FINISHED',
}

export interface WorkflowTriggerBasicAuthConfig {
  username: string;
  password: string;
}

export interface WorkflowTriggerCustomHeaderAuthConfig {
  headerKey: string;
  headerValue: string;
}

export interface WebhookTriggerConfig {
  method: WorkflowTriggerMethod;
  auth: WorkflowTriggerAuthType;
  basicAuthConfig?: WorkflowTriggerBasicAuthConfig;
  headerAuthConfig?: WorkflowTriggerCustomHeaderAuthConfig;
  responseUntil: WebhookTriggerResponseUntil;
}

@Entity({ name: 'workflow_triggers' })
export class WorkflowTriggersEntity extends BaseEntity {
  @Column({
    name: 'workflow_id',
  })
  workflowId: string;

  @Column({
    name: 'workflow_version',
  })
  workflowVersion: number;

  @Column()
  type: WorkflowTriggerType;

  @Column()
  enabled: boolean;

  /**
   * 定时任务具备的参数
   */
  @Column({
    nullable: true,
  })
  cron?: string;

  @Column({
    name: 'next_trigger_time',
    nullable: true,
    type: 'bigint',
  })
  nextTriggerTime?: number;

  @Column({
    name: 'last_trigger_time',
    nullable: true,
    type: 'bigint',
  })
  lastTriggerTime?: number;

  /**
   * Webhook 触发器具备的参数
   */
  @Column({
    name: 'webhook_path',
    nullable: true,
  })
  webhookPath?: string;

  @Column({
    name: 'workflow_config',
    type: 'simple-json',
    nullable: true,
  })
  webhookConfig?: WebhookTriggerConfig;

  @Column({
    name: 'extra_data',
    type: 'simple-json',
    nullable: true,
  })
  extraData?: { [x: string]: any };
}

================================================================================

migrations/1714373691606-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner } from 'typeorm';

const appId = config.server.appId;
export class Migartion1714373691606 implements MigrationInterface {
  name = 'Migartion1714373691606';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE "${appId}_workflow_triggers" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "workflow_id" character varying NOT NULL, "workflow_version" integer NOT NULL, "type" character varying NOT NULL, "enabled" boolean NOT NULL, "cron" character varying, "next_trigger_time" bigint, "last_trigger_time" bigint, "webhook_path" character varying, "workflow_config" text, "extra_data" text, CONSTRAINT "pk_${appId}_workflow_triggers" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_workflow_execution" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "workflow_id" character varying NOT NULL, "workflow_version" integer NOT NULL, "workflow_instance_id" character varying NOT NULL, "user_id" character varying NOT NULL, "trigger_type" character varying NOT NULL, "chat_session_id" character varying, "group" character varying, CONSTRAINT "pk_${appId}_workflow_execution" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_workflow_metadatas" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "workflow_id" character varying NOT NULL, "version" integer NOT NULL, "activated" boolean NOT NULL DEFAULT true, "validated" boolean NOT NULL DEFAULT true, "tasks" text, "variables" text, "output" text, "fork_from_id" character varying, "validation_issues" text, "md5" character varying, "hidden" boolean DEFAULT false, "rate_limiter" text, "expose_openai_compatible_interface" boolean NOT NULL DEFAULT false, "not_authorized" boolean DEFAULT false, "shortcuts_flow" text DEFAULT NULL, CONSTRAINT "pk_${appId}_workflow_metadatas" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_workflow_metadatas"."is_published" IS '此资产是否被发布'; COMMENT ON COLUMN "${appId}_workflow_metadatas"."tasks" IS 'conductor workflow json 定义'; COMMENT ON COLUMN "${appId}_workflow_metadatas"."variables" IS 'workflow 变量'; COMMENT ON COLUMN "${appId}_workflow_metadatas"."output" IS 'workflow output 配置'; COMMENT ON COLUMN "${appId}_workflow_metadatas"."fork_from_id" IS 'fork from'; COMMENT ON COLUMN "${appId}_workflow_metadatas"."validation_issues" IS '工作流校验错误/警告'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_workflow_chat_sessions" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "display_name" character varying NOT NULL, "team_id" character varying NOT NULL, "creator_user_id" character varying NOT NULL, "workflow_id" character varying NOT NULL, "messages" text, CONSTRAINT "pk_${appId}_workflow_chat_sessions" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_tools" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "creator_user_id" character varying, "teamId" character varying, "public" boolean, "type" character varying NOT NULL DEFAULT 'SIMPLE', "namespace" character varying NOT NULL, "name" character varying NOT NULL, "credentials" text, "display_name" character varying NOT NULL, "description" character varying, "categories" text, "icon" character varying, "input" text, "output" text, "rules" text, "extra" text, CONSTRAINT "pk_${appId}_tools" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_tools"."input" IS '表单配置'; COMMENT ON COLUMN "${appId}_tools"."output" IS '输出数据'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_workflow_pages" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "display_name" character varying NOT NULL, "type" character varying NOT NULL, "workflow_id" character varying NOT NULL, "is_builtin" boolean NOT NULL, "team_id" character varying NOT NULL, "permissions" text NOT NULL, "sort_index" integer NOT NULL, "custom_options" text, "pinned" boolean DEFAULT false, CONSTRAINT "pk_${appId}_workflow_pages" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_workflow_templates" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "name" character varying NOT NULL, "desc" character varying NOT NULL, "logo" character varying NOT NULL, "team_id" character varying NOT NULL, "workflow_id" character varying NOT NULL, "workflow_version" integer NOT NULL, "creator_user_id" character varying NOT NULL, "fetch_count" integer NOT NULL, "assets_policy" text NOT NULL, CONSTRAINT "pk_${appId}_workflow_templates" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_tools_trigger_types" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "type" character varying NOT NULL, "namespace" character varying NOT NULL, "display_name" character varying NOT NULL, "description" character varying, "icon" character varying, "properties" text, "workflow_inputs" text, CONSTRAINT "pk_${appId}_tools_trigger_types" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(`CREATE INDEX "idx_${appId}_tools_trigger_types_type" ON "${appId}_tools_trigger_types" ("type") `);
    await queryRunner.query(
      `CREATE TABLE "${appId}_tools_server" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "display_name" character varying NOT NULL, "base_url" character varying NOT NULL, "manifest_url" character varying NOT NULL DEFAULT 'v1', "schema_version" character varying NOT NULL DEFAULT 'v1', "namespace" character varying NOT NULL, "auth" text NOT NULL, "api" text NOT NULL, "trigger_endpoints" text, "credential_endpoints" text, "rate_limiter" text, "health_check" character varying, "health_check_status" character varying, CONSTRAINT "uq_${appId}_tools_server" UNIQUE ("namespace"), CONSTRAINT "pk_${appId}_tools_server" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_tools_credential_types" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "name" character varying NOT NULL, "namespace" character varying NOT NULL, "display_name" character varying NOT NULL, "type" character varying NOT NULL, "description" character varying, "icon_url" character varying, "properties" text NOT NULL, CONSTRAINT "pk_${appId}_tools_credential_types" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_tools_credentials" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying NOT NULL, "display_name" character varying NOT NULL, "creator_user_id" character varying NOT NULL, "type" character varying NOT NULL, CONSTRAINT "pk_${appId}_tools_credentials" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_system_configurations" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "key" character varying NOT NULL, "value" character varying NOT NULL, CONSTRAINT "pk_${appId}_system_configurations" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_users" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "name" character varying, "photo" character varying NOT NULL, "nickname" character varying, "phone" character varying, "email" character varying, "password" character varying, "last_login_at" bigint, "logins_count" integer, "verified" boolean, "is_blocked" boolean, "external_id" character varying, "last_auth_method" character varying, CONSTRAINT "pk_${appId}_users" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(`CREATE INDEX "idx_${appId}_users_external_id" ON "${appId}_users" ("external_id") `);
    await queryRunner.query(`CREATE INDEX "idx_${appId}_users_email" ON "${appId}_users" ("email") `);
    await queryRunner.query(`CREATE INDEX "idx_${appId}_users_phone" ON "${appId}_users" ("phone") `);
    await queryRunner.query(
      `CREATE TABLE "${appId}_team_members" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "user_id" character varying NOT NULL, "team_id" character varying NOT NULL, CONSTRAINT "pk_${appId}_team_members" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_teams" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "name" character varying NOT NULL, "description" character varying, "icon_url" character varying, "logo_url" character varying, "owner_user_id" character varying NOT NULL, "is_builtin" boolean NOT NULL DEFAULT false, "is_public" boolean NOT NULL DEFAULT false, "workflow_task_name_prefix" character varying, "custom_theme" text, "enable_join_request" boolean DEFAULT false, CONSTRAINT "pk_${appId}_teams" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_team_join_requests" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying NOT NULL, "user_id" character varying NOT NULL, "status" character varying NOT NULL, CONSTRAINT "pk_${appId}_team_join_requests" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_themes" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "teamId" character varying, "name" character varying NOT NULL, "primaryColor" character varying, "backgroundColor" character varying, "secondaryBackgroundColor" character varying, "isPublic" boolean, CONSTRAINT "pk_${appId}_themes" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_asset_tags" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying NOT NULL, "name" character varying NOT NULL, "color" character varying, "_pinyin" character varying NOT NULL, CONSTRAINT "pk_${appId}_asset_tags" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_asset_marketplace_tags" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "asset_type" character varying NOT NULL, "name" character varying NOT NULL, "color" character varying, "_pinyin" character varying NOT NULL, CONSTRAINT "pk_${appId}_asset_marketplace_tags" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_asset_marketplace_tag_relations" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "tag_id" character varying NOT NULL, "asset_type" character varying NOT NULL, "asset_id" character varying NOT NULL, CONSTRAINT "pk_${appId}_asset_marketplace_tag_relations" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_asset_filters" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying NOT NULL, "name" character varying NOT NULL, "creator_user_id" character varying, "asset_type" character varying, "rules" text, CONSTRAINT "pk_${appId}_asset_filters" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_asset_tag_relations" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying NOT NULL, "tag_id" character varying NOT NULL, "asset_type" character varying NOT NULL, "asset_id" character varying NOT NULL, CONSTRAINT "pk_${appId}_asset_tag_relations" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_assets_authorization" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "asset_type" character varying NOT NULL, "asset_id" character varying NOT NULL, "target_type" character varying NOT NULL, "target_id" character varying NOT NULL, CONSTRAINT "pk_${appId}_assets_authorization" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_apikey" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying NOT NULL, "creator_user_id" character varying NOT NULL, "api_key" character varying NOT NULL, "status" character varying NOT NULL, "desc" character varying, "applicationId" character varying, "isPrivate" boolean NOT NULL DEFAULT false, CONSTRAINT "pk_${appId}_apikey" PRIMARY KEY ("id"))`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_media_files" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "type" character varying NOT NULL, "url" character varying NOT NULL, "source" character varying NOT NULL, "size" integer NOT NULL, "params" text, "md5" character varying, CONSTRAINT "pk_${appId}_media_files" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_media_files"."is_published" IS '此资产是否被发布'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_knowledge_bases" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "uuid" character varying NOT NULL, "embedding_model" character varying NOT NULL, "dimension" integer NOT NULL, "retrieval_settings" text, CONSTRAINT "pk_${appId}_knowledge_bases" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_knowledge_bases"."is_published" IS '此资产是否被发布'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_knowledge_bases_sql" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "uuid" character varying NOT NULL, CONSTRAINT "pk_${appId}_knowledge_bases_sql" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_knowledge_bases_sql"."is_published" IS '此资产是否被发布'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_canvas_applications" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "app_name" character varying NOT NULL, CONSTRAINT "pk_${appId}_canvas_applications" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_canvas_applications"."is_published" IS '此资产是否被发布'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_sd_models" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "status" character varying NOT NULL, "progress" integer, "md5" character varying NOT NULL, "model_id" character varying NOT NULL, "keywords" character varying NOT NULL, "images" text NOT NULL, "params" text NOT NULL, "type" character varying, "base_model" character varying NOT NULL, "model_format" character varying, "disable_text_to_image" boolean, "disable_image_to_image" boolean, "disable_fine_tune" boolean, "output_models" text, "output_samples" text, "output_logs" text, "output_xyz_test" text, "version" character varying, "civitai_url" character varying, "tags" text, CONSTRAINT "pk_${appId}_sd_models" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_sd_models"."is_published" IS '此资产是否被发布'`,
    );
    await queryRunner.query(
      `CREATE TABLE "${appId}_llm_models" ("id" character varying(128) NOT NULL, "created_timestamp" bigint NOT NULL DEFAULT '1714373691844', "updated_timestamp" bigint NOT NULL DEFAULT '1714373691844', "is_deleted" boolean NOT NULL DEFAULT false, "team_id" character varying, "creator_user_id" character varying, "icon_url" character varying, "display_name" character varying NOT NULL, "description" character varying, "is_preset" boolean NOT NULL DEFAULT false, "is_published" boolean NOT NULL DEFAULT false, "publish_config" text, "base_model" character varying NOT NULL, "lora_model" character varying, "llm_type" character varying NOT NULL, "quantization" character varying, "prompt_template" character varying, "gpu_memory_limit" integer, "context_max_length" integer, "stop" character varying, CONSTRAINT "pk_${appId}_llm_models" PRIMARY KEY ("id")); COMMENT ON COLUMN "${appId}_llm_models"."is_published" IS '此资产是否被发布'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE "${appId}_llm_models"`);
    await queryRunner.query(`DROP TABLE "${appId}_sd_models"`);
    await queryRunner.query(`DROP TABLE "${appId}_canvas_applications"`);
    await queryRunner.query(`DROP TABLE "${appId}_knowledge_bases_sql"`);
    await queryRunner.query(`DROP TABLE "${appId}_knowledge_bases"`);
    await queryRunner.query(`DROP TABLE "${appId}_media_files"`);
    await queryRunner.query(`DROP TABLE "${appId}_apikey"`);
    await queryRunner.query(`DROP TABLE "${appId}_assets_authorization"`);
    await queryRunner.query(`DROP TABLE "${appId}_asset_tag_relations"`);
    await queryRunner.query(`DROP TABLE "${appId}_asset_filters"`);
    await queryRunner.query(`DROP TABLE "${appId}_asset_marketplace_tag_relations"`);
    await queryRunner.query(`DROP TABLE "${appId}_asset_marketplace_tags"`);
    await queryRunner.query(`DROP TABLE "${appId}_asset_tags"`);
    await queryRunner.query(`DROP TABLE "${appId}_themes"`);
    await queryRunner.query(`DROP TABLE "${appId}_team_join_requests"`);
    await queryRunner.query(`DROP TABLE "${appId}_teams"`);
    await queryRunner.query(`DROP TABLE "${appId}_team_members"`);
    await queryRunner.query(`DROP INDEX "public"."idx_${appId}_tools_trigger_types_type"`);
    await queryRunner.query(`DROP INDEX "public"."idx_${appId}_users_external_id"`);
    await queryRunner.query(`DROP INDEX "public"."idx_${appId}_users_phone"`);
    await queryRunner.query(`DROP TABLE "${appId}_users"`);
    await queryRunner.query(`DROP TABLE "${appId}_system_configurations"`);
    await queryRunner.query(`DROP TABLE "${appId}_tools_credentials"`);
    await queryRunner.query(`DROP TABLE "${appId}_tools_credential_types"`);
    await queryRunner.query(`DROP TABLE "${appId}_tools_server"`);
    await queryRunner.query(`DROP INDEX "public"."idx_${appId}_users_email"`);
    await queryRunner.query(`DROP TABLE "${appId}_tools_trigger_types"`);
    await queryRunner.query(`DROP TABLE "${appId}_workflow_templates"`);
    await queryRunner.query(`DROP TABLE "${appId}_workflow_pages"`);
    await queryRunner.query(`DROP TABLE "${appId}_tools"`);
    await queryRunner.query(`DROP TABLE "${appId}_workflow_chat_sessions"`);
    await queryRunner.query(`DROP TABLE "${appId}_workflow_metadatas"`);
    await queryRunner.query(`DROP TABLE "${appId}_workflow_execution"`);
    await queryRunner.query(`DROP TABLE "${appId}_workflow_triggers"`);
  }
}

================================================================================

migrations/1715926119511-add-table-comfyui-workflow.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { ASSET_COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddTableComfyuiWorkflow1715926119511 implements MigrationInterface {
  tableName = `${appId}_comfyui_workflows`;
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.tableName,
        columns: [
          ...ASSET_COMMON_COLUMNS,
          {
            name: 'workflow_type',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'originla_data',
            type: 'text',
            comment: 'Original Data',
          },
          {
            name: 'workflow',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'prompt',
            type: 'text',
          },
          {
            name: 'tool_input',
            type: 'text',
            isNullable: true,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.tableName);
  }
}

================================================================================

migrations/1716396543601-add-columns-for-comfyui-workflow.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { NULLABLE, TEXT } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;
export class MigartionAddColumnsForComfyuiWorkflow1716396543601 implements MigrationInterface {
  TABLE_NAME = `${appId}_comfyui_workflows`;
  ADDITIONAL_MODEL_LIST_COLUMN_NAME = 'additional_model_list';
  ADDITIONAL_NODE_LIST_COLUMN_NAME = 'additional_node_list';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const additioanlModelListExist = await isColumnExist(this.ADDITIONAL_MODEL_LIST_COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!additioanlModelListExist) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.ADDITIONAL_MODEL_LIST_COLUMN_NAME,
          comment: 'Additional Model List',
          ...NULLABLE,
          ...TEXT,
        }),
      );
    }

    const additioanlNodeListExist = await isColumnExist(this.ADDITIONAL_NODE_LIST_COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!additioanlNodeListExist) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.ADDITIONAL_NODE_LIST_COLUMN_NAME,
          comment: 'Additional Node List',
          ...NULLABLE,
          ...TEXT,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.ADDITIONAL_MODEL_LIST_COLUMN_NAME);
    await queryRunner.dropColumn(this.TABLE_NAME, this.ADDITIONAL_NODE_LIST_COLUMN_NAME);
  }
}

================================================================================

migrations/1716551483943-add-column-log-endpoint-for-tools-server.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { NULLABLE, VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnLogEndpointForToolsServer1716551483943 implements MigrationInterface {
  TABLE_NAME = `${appId}_tools_server`;
  COLUMN_NAME = 'log_endpoint';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'Log Endpoint',
          ...NULLABLE,
          ...VARCHAR,
          length: '255',
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1716972169705-add-table-team-invites-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddTableTeamInvites1716972169705 implements MigrationInterface {
  tableName = `${appId}_team_invites`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.tableName,
        columns: [
          ...COMMON_COLUMNS,
          {
            name: 'inviter_user_id',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'target_user_id',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'team_id',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'type',
            type: 'int',
          },
          {
            name: 'outdate_timestamp',
            type: 'bigint',
          },
          {
            name: 'status',
            type: 'int',
          },
          {
            name: 'accepted_user_ids',
            type: 'text',
          },
          {
            name: 'remark',
            type: 'text',
            isNullable: true,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.tableName);
  }
}

================================================================================

migrations/1716975090536-add-table-comfyui-servers-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddTableComfyuiServers1716975090536 implements MigrationInterface {
  tableName = `${appId}_comfyui_servers`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.tableName,
        columns: [
          ...COMMON_COLUMNS,
          {
            name: 'creator_user_id',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'team_id',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'address',
            type: 'varchar',
            length: '1024',
          },
          {
            name: 'status',
            type: 'varchar',
            length: '64',
          },
          {
            name: 'description',
            type: 'varchar',
            length: '1024',
          },
          {
            name: 'is_default',
            type: 'boolean',
            default: false,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.tableName);
  }
}

================================================================================

migrations/1717388296249-add-column-create-type-for-table-sql-knowledge-base.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnCreateTypeForTableSqlKnowledgeBase1717388296249 implements MigrationInterface {
  TABLE_NAME = `${appId}_knowledge_bases_sql`;
  COLUMN_NAME = 'create_type';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'Create Type',
          ...VARCHAR,
          length: '255',
          default: "'builtIn'",
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1717660927388-remove-built-comfyui-workflow-data.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner } from 'typeorm';

const appId = config.server.appId;

export class MigartionRemoveBuiltInComfyuiWorkflow1717660927388 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const comfyuiWorkflowIds = ['664e1fa3103d67fd8406a5f3', '664e1fa3103d67fd8406a5f4'];
    await queryRunner.query(`DELETE FROM ${appId}_comfyui_workflows WHERE "id" IN ('${comfyuiWorkflowIds.join("','")}')`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Do nothing
  }
}

================================================================================

migrations/1717735898524-add-column-tool-output-for-comfyui-workflowmigartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { TEXT } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnToolOutputForComfyuiWorkflows1717735898524 implements MigrationInterface {
  TABLE_NAME = `${appId}_comfyui_workflows`;
  COLUMN_NAME = 'tool_output';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'Toll Output',
          ...TEXT,
          isNullable: true,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1717992010830-add-column-encryped-data.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { TEXT } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnEncryptedData1717992010830 implements MigrationInterface {
  TABLE_NAME = `${appId}_tools_credentials`;
  COLUMN_NAME = 'encrypted_data';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'Encrypted Data',
          ...TEXT,
          isNullable: true,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1717992114097-add-column-rsa-public-key.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnRsaPublicKey1717992114097 implements MigrationInterface {
  TABLE_NAME = `${appId}_tools_server`;
  COLUMN_NAME = 'ras_public_key';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'RSA Public Key',
          ...VARCHAR,
          isNullable: true,
          length: '4096',
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1718360897700-add-column-openai-model-namemigartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnOpenaiModelName1718360897700 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_metadatas`;
  COLUMN_NAME = 'openai_model_name';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'OpenAI Model Name',
          ...VARCHAR,
          isNullable: true,
          length: '128',
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1718809374824-alter-rich-media-size-to-nullablemigartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner } from 'typeorm';

const appId = config.server.appId;
export class MigartionAlterRichMediaSizeNullAble1718809374824 implements MigrationInterface {
  TABLE_NAME = `${appId}_media_files`;
  COLUMN_NAME = 'size';
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE ${this.TABLE_NAME} ALTER COLUMN ${this.COLUMN_NAME} DROP NOT NULL`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE ${this.TABLE_NAME} ALTER COLUMN ${this.COLUMN_NAME} SET NOT NULL`);
  }
}

================================================================================

migrations/1718959051307-add-table-llm-channel-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { ASSET_COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddTableLLMChannels1718959051307 implements MigrationInterface {
  tableName = `${appId}_llm_channels`;
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.tableName,
        columns: [
          ...ASSET_COMMON_COLUMNS,
          {
            name: 'properites',
            type: 'text',
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.tableName);
  }
}

================================================================================

migrations/1719200817122-add-table-oneapi-user.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { COMMON_COLUMNS } from './columns';

const appId = config.server.appId;
export class MigartionAddTableOneapiUser1719200817122 implements MigrationInterface {
  TABLE_NAME = `${appId}_oneapi_users`;
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.TABLE_NAME,
        columns: [
          ...COMMON_COLUMNS,
          {
            name: 'team_id',
            type: 'varchar',
            length: '1024',
          },
          {
            name: 'user_id',
            type: 'integer',
          },
          {
            name: 'user_token',
            type: 'varchar',
            length: '1024',
            isNullable: true,
          },
          {
            name: 'api_key',
            type: 'varchar',
            length: '1024',
            isNullable: true,
          },
          {
            name: 'username',
            type: 'varchar',
            length: '1024',
            isNullable: true,
          },
          {
            name: 'password',
            type: 'varchar',
            length: '1024',
            isNullable: true,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.TABLE_NAME);
  }
}

================================================================================

migrations/1719215095828-add-table-llm-models-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { ASSET_COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddTableLlmMOdels1719215095828 implements MigrationInterface {
  TABLE_NAME = `${appId}_llm_models`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE IF EXISTS ${this.TABLE_NAME}`);
    await queryRunner.createTable(
      new Table({
        name: this.TABLE_NAME,
        columns: [
          ...ASSET_COMMON_COLUMNS,
          {
            name: 'oneapi_channel_type',
            type: 'varchar',
            length: '1024',
            isNullable: true,
          },
          {
            name: 'oneapi_channel_id',
            type: 'integer',
            isNullable: true,
          },
          {
            name: 'oneapi_models',
            type: 'text',
            isNullable: true,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.TABLE_NAME);
  }
}

================================================================================

migrations/1720670723210-add-column-not-authorized-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { BOOL } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColoumnNotAuthorized1720670723210 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_metadatas`;
  COLUMN_NAME = 'not_authorized';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'Can access without authorization',
          ...BOOL,
          isNullable: true,
          default: false,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1720683214065-workflow-page-group-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { config } from '@/common/config';
import { COMMON_COLUMNS } from '@/database/migrations/columns';

const appId = config.server.appId;
export class MigartionWorkflowPageGroup1720683214065 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_page_group`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.TABLE_NAME,
        columns: [
          ...COMMON_COLUMNS,
          {
            name: 'display_name',
            type: 'varchar',
            length: '1024',
          },
          {
            name: 'team_id',
            type: 'varchar',
            length: '1024',
          },
          {
            name: 'is_builtin',
            type: 'boolean',
            default: false,
          },
          {
            name: 'page_ids',
            type: 'text',
            isNullable: true,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.TABLE_NAME);
  }
}

================================================================================

migrations/1720748707927-add-default-group-for-all-built-in-pages-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner } from 'typeorm';
import { config } from '@/common/config';
import { generateDbId } from '@/common/utils';

const appId = config.server.appId;

export class MigartionAddDefaultGroupForAllBuiltInPages1720748707927 implements MigrationInterface {
  TEAMS_TABLE_NAME = `${appId}_teams`;
  GROUP_TABLE_NAME = `${appId}_workflow_page_group`;
  PAGE_TABLE_NAME = `${appId}_workflow_pages`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    // 获取所有 isDelete 为 false 的 team
    const teamIds = (await queryRunner.query(`SELECT DISTINCT id FROM ${this.TEAMS_TABLE_NAME}`)).map((it: { id: string }) => it.id);

    const needToCreateGroupTeamIds: string[] = [];
    // 检查 GROUP_TABLE_NAME 表中是否存在 teamId 为上面的 id 且 is_builtin 为 true 的数据
    for (const teamId of teamIds) {
      const result = await queryRunner.query(
        `
        SELECT EXISTS (
          SELECT 1
          FROM ${this.GROUP_TABLE_NAME}
          WHERE team_id = $1 AND is_builtin = true
        ) AS exists
      `,
        [teamId],
      );

      if (result[0].exists) {
        console.log(`[Y] Team ID ${teamId} has is_builtin = true in ${this.GROUP_TABLE_NAME}`);
      } else {
        console.log(`[F] Team ID ${teamId} does not have is_builtin = true in ${this.GROUP_TABLE_NAME}`);
        needToCreateGroupTeamIds.push(teamId);
      }
    }

    if (needToCreateGroupTeamIds.length) {
      // 获取 PAGE_TABLE_NAME 表中所有团队的 is_builtin 为 true 的数据
      const builtinPages = await queryRunner.query(`SELECT id, team_id FROM ${this.PAGE_TABLE_NAME} WHERE pinned = true`);
      // 转换为：{ teamId: [pageId1, pageId2, ...] }
      const builtinPagesMap: Record<string, string[]> = {};

      for (const { team_id: pageTeamId, id: pageId } of builtinPages) {
        if (needToCreateGroupTeamIds.includes(pageTeamId)) {
          if (!builtinPagesMap[pageTeamId]) {
            builtinPagesMap[pageTeamId] = [];
          }
          builtinPagesMap[pageTeamId].push(pageId);
        }
      }
      console.log(`[D] Found ${builtinPages.length} builtin pages for ${needToCreateGroupTeamIds.length} teams`, builtinPagesMap);

      for (const [targetTeamId, pageIds] of Object.entries(builtinPagesMap)) {
        // 创建新的 group
        const newGroupId = generateDbId();
        const createdTimestamp = Date.now();
        const updatedTimestamp = Date.now();

        await queryRunner.query(
          `
          INSERT INTO ${this.GROUP_TABLE_NAME} (
            id, team_id, display_name, is_builtin, page_ids, created_timestamp, updated_timestamp, is_deleted
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8
          )
        `,
          [newGroupId, targetTeamId, '默认分组', true, JSON.stringify(pageIds), createdTimestamp, updatedTimestamp, false],
        );

        console.log(`Inserted new group with ID ${newGroupId} for team ID ${targetTeamId}`);
      }
    }

    // const groupTable = await queryRunner.getTable(this.GROUP_TABLE_NAME);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {}
}

================================================================================

migrations/1721115912596-add-column-for-table-workflow-execution-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { INT, VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnForWorkflowExecution1721115912596 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_execution`;
  COLUMN_NAME1 = 'status';
  COLUMN_NAME2 = 'takes';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists1 = await isColumnExist(this.COLUMN_NAME1, this.TABLE_NAME, queryRunner);
    if (!exists1) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME1,
          comment: 'Status',
          ...VARCHAR,
          isNullable: true,
          length: '255',
        }),
      );
    }
    const exists2 = await isColumnExist(this.COLUMN_NAME2, this.TABLE_NAME, queryRunner);
    if (!exists2) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME2,
          comment: 'Takes in microseconds',
          ...INT,
          isNullable: true,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME1);
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME2);
  }
}

================================================================================

migrations/1721116431677-add-index-for-table-workflow-execution-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableIndex } from 'typeorm';
import { isIndexExist } from './utils';

const appId = config.server.appId;

export class Migartion1721116431677 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_execution`;
  INDEX_NAME1 = `${appId}_idx_workflow_execution_workflow_id`;
  INDEX_COLUMNS1 = ['workflow_id'];
  INDEX_NAME2 = `${appId}_idx_workflow_execution_workflow_instance_id`;
  INDEX_COLUMNS2 = ['workflow_instance_id'];
  INDEX_NAME3 = `${appId}_idx_workflow_execution_workflow_created_timestamp`;
  INDEX_COLUMNS3 = ['created_timestamp'];
  INDEX_NAME4 = `${appId}_idx_workflow_execution_workflow_status`;
  INDEX_COLUMNS4 = ['status'];
  public async up(queryRunner: QueryRunner): Promise<void> {
    const table = await queryRunner.getTable(this.TABLE_NAME);
    const exist1 = await isIndexExist(this.INDEX_NAME1, this.TABLE_NAME, queryRunner);
    if (!exist1) {
      await queryRunner.createIndex(
        table,
        new TableIndex({
          name: this.INDEX_NAME1,
          columnNames: this.INDEX_COLUMNS1,
          isUnique: false,
        }),
      );
    }
    const exist2 = await isIndexExist(this.INDEX_NAME2, this.TABLE_NAME, queryRunner);
    if (!exist2) {
      await queryRunner.createIndex(
        table,
        new TableIndex({
          name: this.INDEX_NAME2,
          columnNames: this.INDEX_COLUMNS2,
          isUnique: false,
        }),
      );
    }
    const exist3 = await isIndexExist(this.INDEX_NAME3, this.TABLE_NAME, queryRunner);
    if (!exist3) {
      await queryRunner.createIndex(
        table,
        new TableIndex({
          name: this.INDEX_NAME3,
          columnNames: this.INDEX_COLUMNS3,
          isUnique: false,
        }),
      );
    }
    const exist4 = await isIndexExist(this.INDEX_NAME4, this.TABLE_NAME, queryRunner);
    if (!exist4) {
      await queryRunner.createIndex(
        table,
        new TableIndex({
          name: this.INDEX_NAME4,
          columnNames: this.INDEX_COLUMNS4,
          isUnique: false,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropIndex(this.TABLE_NAME, this.INDEX_NAME1);
    await queryRunner.dropIndex(this.TABLE_NAME, this.INDEX_NAME2);
    await queryRunner.dropIndex(this.TABLE_NAME, this.INDEX_NAME3);
    await queryRunner.dropIndex(this.TABLE_NAME, this.INDEX_NAME4);
  }
}

================================================================================

migrations/1721121604853-add-column-apikey-for-workflow-execution-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumnApiKeyForTableWorkflowExecution1721121604853 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_execution`;
  COLUMN_NAME = 'apikey';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'API Key',
          ...VARCHAR,
          isNullable: true,
          length: '255',
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1722223140728-add-table-conversation-app.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { ASSET_COMMON_COLUMNS } from './columns';

const appId = config.server.appId;
export class MigartionAddTableConversationApp1722223140728 implements MigrationInterface {
  tableName = `${appId}_conversation_apps`;
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.tableName,
        columns: [
          ...ASSET_COMMON_COLUMNS,
          {
            name: 'custom_model_name',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'model',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'system_prompt',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'knowledge_base',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'sql_knowledge_base',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'tools',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'temperature',
            type: 'float',
            isNullable: true,
            default: 0.7,
          },
          {
            name: 'presence_penalty',
            type: 'float',
            isNullable: true,
            default: 0.5,
          },
          {
            name: 'frequency_penalty',
            type: 'float',
            isNullable: true,
            default: 0.5,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.tableName);
  }
}

================================================================================

migrations/1722324247892-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddTableConversationExecutions1722324247892 implements MigrationInterface {
  tableName = `${appId}_conversation_executions`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.tableName,
        columns: [
          ...COMMON_COLUMNS,
          {
            name: 'app_id',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'user_id',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'status',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'takes',
            type: 'int',
            isNullable: true,
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.tableName);
  }
}

================================================================================

migrations/1723111778658-conversation-app-prompt-migartion.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner } from 'typeorm';

const appId = config.server.appId;

export class MigartionConversationAppPromptMigartion1723111778658 implements MigrationInterface {
  tableName = `${appId}_conversation_apps`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
            ALTER TABLE "${this.tableName}"
            ALTER COLUMN "system_prompt" TYPE text
        `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
            ALTER TABLE "${this.tableName}"
            ALTER COLUMN "system_prompt" TYPE varchar
        `);
  }
}

================================================================================

migrations/1724846191510-add-table-comfyui-models-types-relations.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, Table } from 'typeorm';
import { ASSET_COMMON_COLUMNS, COMMON_COLUMNS } from './columns';

const appId = config.server.appId;

export class MigartionAddComfyuiModel1724846191510 implements MigrationInterface {
  table1Name = `${appId}_comfyui_model`;
  table2Name = `${appId}_comfyui_model_type`;
  table3Name = `${appId}_comfyui_model_server_relations`;
  serverTable = `${appId}_comfyui_servers`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: this.table1Name,
        columns: [
          ...ASSET_COMMON_COLUMNS,
          {
            name: 'sha256',
            type: 'varchar',
            length: '255',
          },
        ],
      }),
    );
    await queryRunner.createTable(
      new Table({
        name: this.table2Name,
        columns: [
          ...ASSET_COMMON_COLUMNS,
          {
            name: 'name',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'path',
            type: 'varchar',
            length: '255',
          },
        ],
      }),
    );
    await queryRunner.createTable(
      new Table({
        name: this.table3Name,
        columns: [
          ...COMMON_COLUMNS,
          {
            name: 'team_id',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'path',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'filename',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'modelId',
            type: 'varchar',
            length: '128',
            isNullable: true,
          },
          {
            name: 'serverId',
            type: 'varchar',
            length: '128',
            isNullable: true,
          },
        ],
        foreignKeys: [
          {
            columnNames: ['modelId'],
            referencedTableName: this.table1Name,
            referencedColumnNames: ['id'],
            onDelete: 'NO ACTION',
            onUpdate: 'NO ACTION',
          },
          {
            columnNames: ['serverId'],
            referencedTableName: this.serverTable,
            referencedColumnNames: ['id'],
            onDelete: 'NO ACTION',
            onUpdate: 'NO ACTION',
          },
        ],
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable(this.table1Name);
    await queryRunner.dropTable(this.table2Name);
    await queryRunner.dropTable(this.table3Name);
  }
}

================================================================================

migrations/1724905499551-alter-comfyui-model-table.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner } from 'typeorm';

const appId = config.server.appId;

export class MigartionAlterComfyuiModelTable1724905499551 implements MigrationInterface {
  relationTable = `${appId}_comfyui_model_server_relations`;
  modelTable = `${appId}_comfyui_model`;
  serverTable = `${appId}_comfyui_servers`;

  public async up(queryRunner: QueryRunner): Promise<void> {
    const fks: { constraint_name: string }[] = await queryRunner.query(`
        SELECT constraint_name
        FROM information_schema.table_constraints
        WHERE table_name = '${this.relationTable}'
        AND constraint_type = 'FOREIGN KEY'
    `);

    if (fks.length === 2) {
      await queryRunner.query(`
            ALTER TABLE "public"."${this.relationTable}" 
            DROP CONSTRAINT "${fks[0].constraint_name}",
            DROP CONSTRAINT "${fks[1].constraint_name}",
            ADD CONSTRAINT "${fks[0].constraint_name}" FOREIGN KEY ("modelId") REFERENCES "public"."${this.modelTable}" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
            ADD CONSTRAINT "${fks[1].constraint_name}" FOREIGN KEY ("serverId") REFERENCES "public"."${this.serverTable}" ("id") ON DELETE CASCADE ON UPDATE CASCADE;
        `);
    }

    await queryRunner.query(`
        ALTER TABLE "public"."${this.relationTable}" 
        ALTER COLUMN "team_id" DROP NOT NULL;`);
  }

  public async down(_queryRunner: QueryRunner): Promise<void> {}
}

================================================================================

migrations/1730138526826-add-column.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { VARCHAR } from './columns';
import { isColumnExist } from './utils';

const appId = config.server.appId;

export class MigartionAddColumn1730138526826 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_metadatas`;
  COLUMN_NAME = 'thumbnail';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: '缩略图',
          ...VARCHAR,
          isNullable: true,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1732626882020-add-shortcuts-flow-to-workflow-metadata-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { isColumnExist } from '@/database/migrations/utils';
import { TEXT } from '@/database/migrations/columns';
import { config } from '@/common/config';

const appId = config.server.appId;

export class MigartionAddShortcutsFlow1732626882020 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_metadatas`;
  COLUMN_NAME = 'shortcuts_flow';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'shortcuts workflow id',
          ...TEXT,
          isNullable: true,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1732669696629-add-column-execution-group-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
import { isColumnExist } from '@/database/migrations/utils';
import { VARCHAR } from '@/database/migrations/columns';

import { config } from '@/common/config';

const appId = config.server.appId;

export class MigartionAddColumnExecutionGroup1732669696629 implements MigrationInterface {
  TABLE_NAME = `${appId}_workflow_execution`;
  COLUMN_NAME = 'group';
  public async up(queryRunner: QueryRunner): Promise<void> {
    const exists = await isColumnExist(this.COLUMN_NAME, this.TABLE_NAME, queryRunner);
    if (!exists) {
      await queryRunner.addColumn(
        this.TABLE_NAME,
        new TableColumn({
          name: this.COLUMN_NAME,
          comment: 'Execution Record Grouping',
          ...VARCHAR,
          isNullable: true,
        }),
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1745922805471-add-table-workflow-observability-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner, Table } from 'typeorm';

import { COMMON_COLUMNS } from './columns';

import { config } from '@/common/config';

const appId = config.server.appId;

export class MigartionAddWorkflowObservability1745922805471 implements MigrationInterface {
    tableName = `${appId}_workflow_observability`;

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.createTable(
            new Table({
                name: this.tableName,
                columns: [
                    ...COMMON_COLUMNS,
                    {
                        name: 'workflow_id',
                        type: 'varchar',
                        length: '255',
                    },
                    {
                        name: 'team_id',
                        type: 'varchar',
                        length: '255',
                    },
                    {
                        name: 'name',
                        type: 'varchar',
                        length: '255',
                        isNullable: true,
                    },
                    {
                        name: 'platform',
                        type: 'varchar',
                        length: '255',
                    },
                    {
                        name: 'platform_config',
                        type: 'text',
                    },
                ],
            }),
        );
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.dropTable(this.tableName);
    }
}

================================================================================

migrations/1746762866441-add-darkmode-team-icon.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';
const appId = config.server.appId;
export class AddDarkmodeTeamIcon1746762866441 implements MigrationInterface {
  TABLE_NAME = `${appId}_teams`;
  COLUMN_NAME = `darkmode_icon_url`;
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.addColumn(
      this.TABLE_NAME,
      new TableColumn({
        name: this.COLUMN_NAME,
        type: 'varchar',
        isNullable: true,
      }),
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn(this.TABLE_NAME, this.COLUMN_NAME);
  }
}

================================================================================

migrations/1748344827526-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner } from "typeorm";

export class Migartion1748344827526 implements MigrationInterface {
    name = 'Migartion1748344827526'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "created_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "updated_timestamp" TIMESTAMP NOT NULL DEFAULT now()`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_sd_models" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_canvas_applications" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_knowledge_bases_sql" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_media_files" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_apikey" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_filters" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tags" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_assets_authorization" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tag_relations" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_marketplace_tags" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_asset_tag_relations" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_server_relations" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_themes" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_join_requests" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_members" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_users" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_system_configurations" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credential_types" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_trigger_types" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_chat_sessions" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_pages" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_triggers" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" DROP COLUMN "updated_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" ADD "updated_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" DROP COLUMN "created_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_templates" ADD "created_timestamp" bigint NOT NULL DEFAULT '1748344775167'`);
    }

}

================================================================================

migrations/1748510326422-migartion.ts:
--------------------------------------------------------------------------------
import { MigrationInterface, QueryRunner } from "typeorm";

export class Migartion1748510326422 implements MigrationInterface {
    name = 'Migartion1748510326422'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`DROP INDEX "public"."monkeys_idx_workflow_execution_workflow_id"`);
        await queryRunner.query(`DROP INDEX "public"."monkeys_idx_workflow_execution_workflow_instance_id"`);
        await queryRunner.query(`DROP INDEX "public"."monkeys_idx_workflow_execution_workflow_status"`);
        await queryRunner.query(`DROP INDEX "public"."idx_monkeys_tools_trigger_types_type"`);
        await queryRunner.query(`DROP INDEX "public"."idx_monkeys_users_external_id"`);
        await queryRunner.query(`DROP INDEX "public"."idx_monkeys_users_email"`);
        await queryRunner.query(`DROP INDEX "public"."idx_monkeys_users_phone"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "credential_endpoints"`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" DROP COLUMN "logo_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ALTER COLUMN "is_builtin" DROP DEFAULT`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "team_id" character varying NOT NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_workflow_execution"."status" IS NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_workflow_execution"."takes" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" DROP COLUMN "apikey"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" ADD "apikey" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" DROP COLUMN "openai_model_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ADD "openai_model_name" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_workflow_metadatas"."thumbnail" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ALTER COLUMN "thumbnail" SET DEFAULT false`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "log_endpoint"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "log_endpoint" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_tools_server"."ras_public_key" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" ALTER COLUMN "encrypted_data" SET NOT NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_tools_credentials"."encrypted_data" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ALTER COLUMN "user_id" DROP NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "user_token"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "user_token" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "api_key"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "api_key" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "username"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "username" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "password"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "password" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "workflow_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "workflow_id" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "team_id" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "name" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "platform"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "platform" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "app_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "app_id" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "user_id" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "inviter_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "inviter_user_id" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "target_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "target_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ALTER COLUMN "team_id" SET NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "outdate_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "outdate_timestamp" integer NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "creator_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "icon_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "description" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_conversation_apps"."is_published" IS '此资产是否被发布'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "custom_model_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "custom_model_name" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "model"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "model" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "knowledge_base"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "knowledge_base" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "sql_knowledge_base"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "sql_knowledge_base" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ALTER COLUMN "temperature" SET DEFAULT '0.7'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ALTER COLUMN "presence_penalty" SET DEFAULT '0.5'`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ALTER COLUMN "frequency_penalty" SET DEFAULT '0.5'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "creator_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "icon_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "description" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."is_published" IS '此资产是否被发布'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ALTER COLUMN "prompt" DROP NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ALTER COLUMN "tool_input" SET NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ALTER COLUMN "tool_output" SET NOT NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."tool_output" IS NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."additional_model_list" IS NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."additional_node_list" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "creator_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "icon_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "description" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_model"."is_published" IS '此资产是否被发布'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "team_id" character varying(1024)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "creator_user_id" character varying(1024)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ALTER COLUMN "status" SET DEFAULT 'UNKOWN'`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_knowledge_bases_sql"."create_type" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "creator_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "icon_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "description" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_llm_channels"."is_published" IS '此资产是否被发布'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "creator_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "icon_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "description" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_llm_models"."is_published" IS '此资产是否被发布'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "oneapi_channel_type"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "oneapi_channel_type" integer`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_llm_models"."oneapi_channel_type" IS 'LLM Channel Type'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "oneapi_channel_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "oneapi_channel_id" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "team_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "creator_user_id" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "icon_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "display_name" character varying NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "description" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_model_type"."is_published" IS '此资产是否被发布'`);
        await queryRunner.query(`CREATE INDEX "IDX_02f832376be091402b33db3b54" ON "monkeys_tools_trigger_types" ("type") `);
        await queryRunner.query(`CREATE INDEX "IDX_e7831ec9625bee9d555b5a75c8" ON "monkeys_users" ("external_id") `);
        await queryRunner.query(`CREATE INDEX "IDX_1927ab12c4ad3d345b922de232" ON "monkeys_users" ("email") `);
        await queryRunner.query(`CREATE INDEX "IDX_be7443c72d752c340b1238d7d6" ON "monkeys_users" ("phone") `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`DROP INDEX "public"."IDX_be7443c72d752c340b1238d7d6"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_1927ab12c4ad3d345b922de232"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_e7831ec9625bee9d555b5a75c8"`);
        await queryRunner.query(`DROP INDEX "public"."IDX_02f832376be091402b33db3b54"`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_model_type"."is_published" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "description" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "display_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "icon_url" character varying(512)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "creator_user_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model_type" ADD "team_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "oneapi_channel_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "oneapi_channel_id" integer`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_llm_models"."oneapi_channel_type" IS 'LLM Channel Type'`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "oneapi_channel_type"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "oneapi_channel_type" character varying(1024)`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_llm_models"."is_published" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "description" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "display_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "icon_url" character varying(512)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "creator_user_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_models" ADD "team_id" character varying(128)`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_llm_channels"."is_published" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "description" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "display_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "icon_url" character varying(512)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "creator_user_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_llm_channels" ADD "team_id" character varying(128)`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_knowledge_bases_sql"."create_type" IS 'Create Type'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ALTER COLUMN "status" DROP DEFAULT`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "creator_user_id" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_servers" ADD "team_id" character varying`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_model"."is_published" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "description" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "display_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "icon_url" character varying(512)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "creator_user_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_model" ADD "team_id" character varying(128)`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."additional_node_list" IS 'Additional Node List'`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."additional_model_list" IS 'Additional Model List'`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."tool_output" IS 'Toll Output'`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ALTER COLUMN "tool_output" DROP NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ALTER COLUMN "tool_input" DROP NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ALTER COLUMN "prompt" SET NOT NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_comfyui_workflows"."is_published" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "description" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "display_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "icon_url" character varying(512)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "creator_user_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_comfyui_workflows" ADD "team_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ALTER COLUMN "frequency_penalty" SET DEFAULT 0.5`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ALTER COLUMN "presence_penalty" SET DEFAULT 0.5`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ALTER COLUMN "temperature" SET DEFAULT 0.7`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "sql_knowledge_base"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "sql_knowledge_base" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "knowledge_base"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "knowledge_base" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "model"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "model" character varying(255) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "custom_model_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "custom_model_name" character varying(255)`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_conversation_apps"."is_published" IS NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "description"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "description" text`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "display_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "icon_url"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "icon_url" character varying(512)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "creator_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "creator_user_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_apps" ADD "team_id" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "outdate_timestamp"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "outdate_timestamp" bigint NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ALTER COLUMN "team_id" DROP NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "target_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "target_user_id" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" DROP COLUMN "inviter_user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_team_invites" ADD "inviter_user_id" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "user_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "user_id" character varying(255) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" DROP COLUMN "app_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_conversation_executions" ADD "app_id" character varying(255) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "platform"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "platform" character varying(255) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "name" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "team_id" character varying(255) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" DROP COLUMN "workflow_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_observability" ADD "workflow_id" character varying(255) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "password"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "password" character varying(1024)`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "username"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "username" character varying(1024)`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "api_key"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "api_key" character varying(1024)`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "user_token"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "user_token" character varying(1024)`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ALTER COLUMN "user_id" SET NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_oneapi_users" ADD "team_id" character varying(1024) NOT NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_tools_credentials"."encrypted_data" IS 'Encrypted Data'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_credentials" ALTER COLUMN "encrypted_data" DROP NOT NULL`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_tools_server"."ras_public_key" IS 'RSA Public Key'`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" DROP COLUMN "log_endpoint"`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "log_endpoint" character varying(255)`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ALTER COLUMN "thumbnail" DROP DEFAULT`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_workflow_metadatas"."thumbnail" IS '缩略图'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" DROP COLUMN "openai_model_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_metadatas" ADD "openai_model_name" character varying(128)`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" DROP COLUMN "apikey"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_execution" ADD "apikey" character varying(255)`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_workflow_execution"."takes" IS 'Takes in microseconds'`);
        await queryRunner.query(`COMMENT ON COLUMN "monkeys_workflow_execution"."status" IS 'Status'`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "team_id"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "team_id" character varying(1024) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ALTER COLUMN "is_builtin" SET DEFAULT false`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" DROP COLUMN "display_name"`);
        await queryRunner.query(`ALTER TABLE "monkeys_workflow_page_group" ADD "display_name" character varying(1024) NOT NULL`);
        await queryRunner.query(`ALTER TABLE "monkeys_teams" ADD "logo_url" character varying`);
        await queryRunner.query(`ALTER TABLE "monkeys_tools_server" ADD "credential_endpoints" text`);
        await queryRunner.query(`CREATE INDEX "idx_monkeys_users_phone" ON "monkeys_users" ("phone") `);
        await queryRunner.query(`CREATE INDEX "idx_monkeys_users_email" ON "monkeys_users" ("email") `);
        await queryRunner.query(`CREATE INDEX "idx_monkeys_users_external_id" ON "monkeys_users" ("external_id") `);
        await queryRunner.query(`CREATE INDEX "idx_monkeys_tools_trigger_types_type" ON "monkeys_tools_trigger_types" ("type") `);
        await queryRunner.query(`CREATE INDEX "monkeys_idx_workflow_execution_workflow_status" ON "monkeys_workflow_execution" ("status") `);
        await queryRunner.query(`CREATE INDEX "monkeys_idx_workflow_execution_workflow_instance_id" ON "monkeys_workflow_execution" ("workflow_instance_id") `);
        await queryRunner.query(`CREATE INDEX "monkeys_idx_workflow_execution_workflow_id" ON "monkeys_workflow_execution" ("workflow_id") `);
    }

}

================================================================================

migrations/columns/index.ts:
--------------------------------------------------------------------------------
const CURRENT_TIMESTAMP = +new Date();

export const NOT_NULL = {
  isNullable: false,
};

export const NULLABLE = {
  isNullable: true,
};

export const VARCHAR = {
  type: 'varchar',
};

export const BOOL = {
  type: 'bool',
};

export const TEXT = {
  type: 'text',
};

export const SMALL_INT = {
  type: 'smallint',
};

export const INT = {
  type: 'int',
};

export const LONG_INT = {
  type: 'bigint',
};

export const TIMESTAMP = {
  type: 'timestamp',
};

export const JSON = {
  type: 'json',
};

export const ID = {
  name: 'id',
  type: 'varchar',
  isNullable: false,
  isPrimary: true,
  length: '128',
};

export const CREATED_TIMESTAMP = {
  name: 'created_timestamp',
  type: 'bigint',
  isNullable: false,
  default: CURRENT_TIMESTAMP,
};

export const UPDATED_TIMESTAMP = {
  name: 'updated_timestamp',
  type: 'bigint',
  isNullable: false,
  default: CURRENT_TIMESTAMP,
};

export const IS_DELETED = {
  name: 'is_deleted',
  type: 'boolean',
  isNullable: false,
  default: false,
};

export const TEAM_ID = {
  name: 'team_id',
  type: 'varchar',
  isNullable: true,
  length: '128',
};

export const CREATOR_USER_ID = {
  name: 'creator_user_id',
  type: 'varchar',
  isNullable: true,
  length: '128',
};

export const ICON_URL = {
  name: 'icon_url',
  type: 'varchar',
  isNullable: true,
  length: '512',
};

export const DISPLAY_NAME = {
  name: 'display_name',
  type: 'varchar',
  isNullable: true,
  length: '128',
};

export const DESCRIPTION = {
  name: 'description',
  type: 'text',
  isNullable: true,
};

export const IS_PRESET = {
  name: 'is_preset',
  type: 'boolean',
  isNullable: false,
  default: false,
};

export const IS_PUBLISHED = {
  name: 'is_published',
  type: 'boolean',
  isNullable: false,
  default: false,
};

export const PUBLISH_CONFIG = {
  name: 'publish_config',
  type: 'text',
  isNullable: true,
};

export const COMMON_COLUMNS = [ID, CREATED_TIMESTAMP, UPDATED_TIMESTAMP, IS_DELETED];

export const ASSET_COMMON_COLUMNS = [ID, CREATED_TIMESTAMP, UPDATED_TIMESTAMP, IS_DELETED, TEAM_ID, CREATOR_USER_ID, ICON_URL, DISPLAY_NAME, DESCRIPTION, IS_PRESET, IS_PUBLISHED, PUBLISH_CONFIG];

================================================================================

migrations/utils/index.ts:
--------------------------------------------------------------------------------
import { QueryRunner } from 'typeorm';

export const isColumnExist = async (columnName: string, tableName: string, queryRunner: QueryRunner) => {
  const table = await queryRunner.getTable(tableName);
  const column = table?.columns.find((c) => c.name === columnName);
  return !!column;
};

export const isIndexExist = async (indexName: string, tableName: string, queryRunner: QueryRunner) => {
  const table = await queryRunner.getTable(tableName);
  const index = table?.indices.find((i) => i.name === indexName);
  return !!index;
};

export const isTableExist = async (tableName: string, queryRunner: QueryRunner) => {
  const table = await queryRunner.getTable(tableName);
  return !!table;
};

================================================================================

repositories.module.ts:
--------------------------------------------------------------------------------
import { Global, Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { entities } from './database.module';
import { ApikeyRepository } from './repositories/apikey.repository';
import { CanvasAssetRepositroy } from './repositories/assets-canvas.repository';
import { ComfyuiModelTypeAssetRepositroy } from './repositories/assets-comfyui-model-type.repositor';
import { ComfyuiModelAssetRepositroy } from './repositories/assets-comfyui-model.repository';
import { ComfyuiWorkflowAssetRepositroy } from './repositories/assets-comfyui-workflow.respository';
import { AssetsCommonRepository } from './repositories/assets-common.repository';
import { ConversationAppAssetRepositroy } from './repositories/assets-conversation-app.repository';
import { SqlKnowledgeBaseAssetRepositroy } from './repositories/assets-knowledge-base-sql.repository';
import { KnowledgeBaseAssetRepositroy } from './repositories/assets-knowledge-base.repository';
import { LlmChannelAssetRepositroy } from './repositories/assets-llm-channel.respository';
import { LlmModelAssetRepositroy } from './repositories/assets-llm-model.respository';
import { AssetsMarketPlaceRepository } from './repositories/assets-marketplace.repository';
import { MediaFileAssetRepositroy } from './repositories/assets-media-file.repository';
import { SdModelAssetRepositroy } from './repositories/assets-sd-model.repository';
import { WorkflowAssetRepositroy } from './repositories/assets-workflow.respository';
import { ComfyuiModelRepository } from './repositories/comfyui-model.repository';
import { ComfyuiRepository } from './repositories/comfyui.repository';
import { ConversationAppRepository } from './repositories/conversation-app.repository';
import { CredentialsRepository } from './repositories/credential.repository';
import { SqlKnowledgeBaseRepository } from './repositories/knowledge-base-sql.repository';
import { KnowledgeBaseRepository } from './repositories/knowledge-base.repository';
import { LlmModelRepository } from './repositories/llm-model.repository';
import { MediaFileRepository } from './repositories/media.repository';
import { ObservabilityRepository } from './repositories/observability.repository';
import { OneApiRepository } from './repositories/oneapi.respository';
import { SdModelRepository } from './repositories/sd-model.repository';
import { SystemConfigurationRepository } from './repositories/system-configuration.repository';
import { TeamRepository } from './repositories/team.repository';
import { ToolsRepository } from './repositories/tools.repository';
import { TriggerTypeRepository } from './repositories/trigger-type.repository';
import { UserRepository } from './repositories/user.repository';
import { WorkflowRepository } from './repositories/workflow.repository';

@Global()
@Module({
  providers: [
    ToolsRepository,
    WorkflowRepository,
    CredentialsRepository,
    SystemConfigurationRepository,
    UserRepository,
    TeamRepository,
    ApikeyRepository,
    AssetsCommonRepository,
    CanvasAssetRepositroy,
    LlmModelAssetRepositroy,
    LlmChannelAssetRepositroy,
    SdModelAssetRepositroy,
    KnowledgeBaseAssetRepositroy,
    MediaFileAssetRepositroy,
    WorkflowAssetRepositroy,
    MediaFileRepository,
    TriggerTypeRepository,
    KnowledgeBaseRepository,
    SqlKnowledgeBaseAssetRepositroy,
    SqlKnowledgeBaseRepository,
    LlmModelRepository,
    SdModelRepository,
    AssetsMarketPlaceRepository,
    ComfyuiRepository,
    ComfyuiWorkflowAssetRepositroy,
    ComfyuiModelRepository,
    ComfyuiModelAssetRepositroy,
    ComfyuiModelTypeAssetRepositroy,
    OneApiRepository,
    ConversationAppRepository,
    ConversationAppAssetRepositroy,
    ObservabilityRepository,
  ],
  exports: [
    ToolsRepository,
    WorkflowRepository,
    CredentialsRepository,
    SystemConfigurationRepository,
    UserRepository,
    TeamRepository,
    ApikeyRepository,
    AssetsCommonRepository,
    CanvasAssetRepositroy,
    LlmModelAssetRepositroy,
    LlmChannelAssetRepositroy,
    SdModelAssetRepositroy,
    KnowledgeBaseAssetRepositroy,
    MediaFileAssetRepositroy,
    WorkflowAssetRepositroy,
    MediaFileRepository,
    TriggerTypeRepository,
    KnowledgeBaseRepository,
    SqlKnowledgeBaseAssetRepositroy,
    SqlKnowledgeBaseRepository,
    LlmModelRepository,
    SdModelRepository,
    AssetsMarketPlaceRepository,
    ComfyuiRepository,
    ComfyuiWorkflowAssetRepositroy,
    ComfyuiModelRepository,
    ComfyuiModelAssetRepositroy,
    ComfyuiModelTypeAssetRepositroy,
    OneApiRepository,
    ConversationAppRepository,
    ConversationAppAssetRepositroy,
    ObservabilityRepository,
  ],
  imports: [TypeOrmModule.forFeature(entities)],
})
export class RepositoryMoule { }

================================================================================

repositories/apikey.repository.ts:
--------------------------------------------------------------------------------
import { generateDbId } from '@/common/utils';
import { generateRandomApiKey } from '@/common/utils/apikey';
import { ApiKeyEntity, ApiKeyStatus } from '@/database/entities/apikey/apikey';
import { CreateApiKeyDto } from '@/modules/auth/apikey/dto/create-apikey.dto';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

@Injectable()
export class ApikeyRepository {
  constructor(
    @InjectRepository(ApiKeyEntity)
    public readonly apiKeyRepo: Repository<ApiKeyEntity>,
  ) {}

  public async validateApiKey(apiKey: string): Promise<{ valid: boolean; teamId?: string; userId?: string }> {
    const entity = await this.apiKeyRepo.findOne({
      where: {
        apiKey,
        isDeleted: false,
      },
    });
    if (!entity) {
      return { valid: false };
    }
    return {
      valid: entity.status === ApiKeyStatus.Valid,
      teamId: entity.teamId,
      userId: entity.creatorUserId,
    };
  }

  public async createApiKey(userId: string, teamId: string, body: CreateApiKeyDto) {
    const apiKey = generateRandomApiKey();
    const { desc } = body;
    const record: ApiKeyEntity = {
      id: generateDbId(),
      creatorUserId: userId,
      teamId,
      apiKey,
      status: ApiKeyStatus.Valid,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      desc,
      isDeleted: false,
    };
    await this.apiKeyRepo.save(record);
    return record;
  }

  public async listApiKeys(userId: string, teamId: string) {
    const data = await this.apiKeyRepo.find({
      where: {
        creatorUserId: userId,
        teamId,
        isDeleted: false,
      },
      order: {
        id: -1,
      },
    });
    return data.filter((d) => ['auto generated by workflowId', '系统自动', '画板 授权'].every((s) => !d?.desc?.includes(s)));
  }

  public async revokeApiKey(userId: string, teamId: string, keyId: string) {
    await this.apiKeyRepo.update(
      {
        id: keyId,
        creatorUserId: userId,
        teamId,
        isDeleted: false,
      },
      {
        status: ApiKeyStatus.Revoked,
        updatedTimestamp: Date.now(),
      },
    );
    return true;
  }

  public async initApiKeyIfNotExists(teamId: string, userId: string) {
    const count = await this.apiKeyRepo.count({
      where: {
        teamId,
        creatorUserId: userId,
        isDeleted: false,
      },
    });
    if (count === 0) {
      await this.createApiKey(userId, teamId, {
        desc: 'Creaetd by system',
      });
    }
  }
}

================================================================================

repositories/assets-abstract.repository.ts:
--------------------------------------------------------------------------------
import { AssetFilter, ListDto } from '@/common/dto/list.dto';
import { generateDbId } from '@/common/utils';
import { AssetType } from '@inf-monkeys/monkeys';
import _ from 'lodash';
import { Between, FindManyOptions, FindOptionsOrder, FindOptionsWhere, In, LessThanOrEqual, MoreThanOrEqual, Repository } from 'typeorm';
import { AssetPublishConfig, BaseAssetEntity } from '../entities/assets/base-asset';
import { AssetsCommonRepository, AssetsFillAdditionalInfoOptions } from './assets-common.repository';

export class AbstractAssetRepository<E extends BaseAssetEntity> {
  constructor(
    public readonly repository: Repository<E>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {}

  public async findAssetIdsByCommonFilter(assetType: AssetType, filter: AssetFilter, assetIdField: string = 'id') {
    const condition: FindOptionsWhere<BaseAssetEntity> = {};
    if (filter.createdTimestamp) {
      const [startCreatedTimestamp, endCreatedTimestamp] = filter.createdTimestamp;
      if (startCreatedTimestamp && endCreatedTimestamp) {
        condition.createdTimestamp = Between(Number(startCreatedTimestamp), Number(endCreatedTimestamp));
      } else if (startCreatedTimestamp) {
        condition.createdTimestamp = MoreThanOrEqual(Number(startCreatedTimestamp));
      } else if (endCreatedTimestamp) {
        condition.createdTimestamp = LessThanOrEqual(Number(endCreatedTimestamp));
      }
    }
    if (filter.updatedTimestamp) {
      const [startUpdatedTimestamp, endUpdatedTimestamp] = filter.updatedTimestamp;
      if (startUpdatedTimestamp && endUpdatedTimestamp) {
        condition.updatedTimestamp = Between(Number(startUpdatedTimestamp), Number(endUpdatedTimestamp));
      } else if (startUpdatedTimestamp) {
        condition.updatedTimestamp = MoreThanOrEqual(Number(startUpdatedTimestamp));
      } else if (endUpdatedTimestamp) {
        condition.updatedTimestamp = LessThanOrEqual(Number(endUpdatedTimestamp));
      }
    }
    if (filter.tagIds?.length) {
      const assetIds = await this.assetCommonRepository.findAssetIdsByTagIds(assetType, filter.tagIds);
      if (assetIds.length) {
        condition[assetIdField] = In(assetIds);
      }
    }
    if (filter.marketPlaceTagIds?.length) {
      const assetIds = await this.assetCommonRepository.findAssetIdsByMarketplaceTagIds(assetType, filter.marketPlaceTagIds);
      if (assetIds.length) condition[assetIdField] = In(assetIds);
    }
    if (filter.userIds?.length) {
      condition.creatorUserId = In(filter.userIds);
    }
    const assets = await this.repository.find({
      where: condition as unknown as FindOptionsWhere<E>,
    });
    return assets.map((x) => x.getAssetId());
  }

  public async getAssetById(id: string, additionQuery: Record<string, any> = {}, options?: AssetsFillAdditionalInfoOptions): Promise<E | undefined> {
    const entity = await this.repository.findOne({
      where: {
        isDeleted: false,
        isPublished: false,
        id: id,
        ...additionQuery,
      } as Partial<E> as FindOptionsWhere<E>,
    });
    return await this.assetCommonRepository.fillAdditionalInfo(entity, options);
  }

  public async listAssets(
    assetType: AssetType,
    teamId: string,
    dto: ListDto,
    options?: AssetsFillAdditionalInfoOptions,
    findOptions?: FindManyOptions<E>,
    extraWhere?: FindOptionsWhere<E>,
  ): Promise<{
    list: E[];
    totalCount: number;
  }> {
    const [DEFAULT_PAGE, DEFAULT_LIMIT] = [1, 24];
    const { page = DEFAULT_PAGE, limit = DEFAULT_LIMIT, filter, orderBy = 'DESC', orderColumn = 'createdTimestamp' } = dto ?? {};
    const authorizedIds = await this.assetCommonRepository.listAuthorizedAssetIds(teamId, assetType);
    let idsConstraints = [];
    if (filter) {
      idsConstraints = await this.findAssetIdsByCommonFilter(assetType, filter);
      if (!idsConstraints.length) {
        return {
          totalCount: 0,
          list: [],
        };
      }
    }

    let list = await this.repository.find({
      where: [
        {
          teamId,
          isDeleted: false,
          isPublished: false,
          id: idsConstraints.length ? In(idsConstraints) : undefined,
          ...extraWhere,
        },
        {
          id: In(authorizedIds),
          isDeleted: false,
          isPublished: false,
          ...extraWhere,
        },
      ] as FindOptionsWhere<E>[],
      order: {
        [orderColumn]: orderBy,
      } as FindOptionsOrder<E>,
      take: +limit,
      skip: (+page - 1) * +limit,
      ...findOptions,
    });
    const totalCount = await this.repository.count({
      where: [
        {
          teamId,
          isDeleted: false,
          isPublished: false,
        },
        {
          id: In(authorizedIds),
          isDeleted: false,
          isPublished: false,
        },
      ] as FindOptionsWhere<E>[],
      order: {
        createdTimestamp: -1,
      } as FindOptionsOrder<E>,
      take: +limit,
      skip: (+page - 1) * +limit,
    });

    list = await this.assetCommonRepository.fillAdditionalInfoList(list, options);
    return {
      list,
      totalCount,
    };
  }

  public async listPublishedAssets(
    assetType: AssetType,
    dto: ListDto,
    options?: AssetsFillAdditionalInfoOptions,
  ): Promise<{
    list: E[];
    totalCount: number;
  }> {
    const [DEFAULT_PAGE, DEFAULT_LIMIT] = [1, 24];
    const { page = DEFAULT_PAGE, limit = DEFAULT_LIMIT, filter, orderBy = 'DESC', orderColumn = 'createdTimestamp' } = dto ?? {};
    let idsConstraints = [];
    if (filter) {
      idsConstraints = await this.findAssetIdsByCommonFilter(assetType, filter);
      if (!idsConstraints.length) {
        return {
          totalCount: 0,
          list: [],
        };
      }
    }

    const list = await this.repository.find({
      where: [
        {
          isDeleted: false,
          id: idsConstraints.length ? In(idsConstraints) : undefined,
          isPublished: true,
        },
      ] as FindOptionsWhere<E>[],
      order: {
        [orderColumn]: orderBy,
      } as FindOptionsOrder<E>,
      take: +limit,
      skip: (+page - 1) * +limit,
    });
    const totalCount = await this.repository.count({
      where: [
        {
          isDeleted: false,
          id: idsConstraints.length ? In(idsConstraints) : undefined,
          isPublished: true,
        },
      ] as FindOptionsWhere<E>[],
      order: {
        createdTimestamp: -1,
      } as FindOptionsOrder<E>,
      take: +limit,
      skip: (+page - 1) * +limit,
    });

    return {
      list: await this.assetCommonRepository.fillAdditionalInfoList(list, options),
      totalCount,
    };
  }

  public async publishAsset(teamId: string, assetId: string, publishConfig: AssetPublishConfig, metadata?: E) {
    let asset = metadata || (await this.getAssetById(assetId));
    if (!asset) {
      throw new Error('资产不存在');
    }
    if (asset.teamId !== teamId) {
      throw new Error('无权限操作此资产');
    }
    const isPreset = asset.isPreset;
    if (isPreset) {
      throw new Error('无法发布预置资产');
    }

    const extraAssetData = _.get(publishConfig, 'extraAssetData');
    let id = generateDbId();
    if (asset.assetType === 'workflow') {
      const publishedAsset = await this.repository.findOne({
        where: {
          forkFromId: assetId,
          isDeleted: false,
          isPublished: true,
          teamId,
        } as unknown as FindOptionsWhere<E>,
      });
      if (publishedAsset) {
        asset = publishedAsset;
        id = publishedAsset.id;
      }
    }
    const clonedAsset = this.repository.create({
      ...asset,
      ...extraAssetData,
      workflowId: asset.assetType === 'workflow' ? id : undefined,
      id,
      teamId,
      forkFromId: assetId,
      isDeleted: false,
      isPreset: false,
      isPublished: true,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      publishConfig: _.omit(publishConfig, 'extraAssetData'),
    });
    await this.repository.save(clonedAsset);
    return clonedAsset;
  }

  public async forkAsset(teamId: string, assetId: string, metadata?: E) {
    const asset =
      metadata ||
      (await this.getAssetById(assetId, {
        isPublished: true,
      }));
    if (!asset) {
      throw new Error('资产不存在');
    }
    if (!asset.isPublished) {
      throw new Error('此资产未发布');
    }
    if (asset.teamId === teamId) {
      throw new Error('此资产由此团队发布，不能克隆');
    }
    const clonedAsset = this.repository.create({
      ...asset,
      id: generateDbId(),
      teamId,
      forkedFrom: assetId,
      isDeleted: false,
      isPreset: false,
      isPublished: false,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
    });
    await this.repository.save(clonedAsset);
    return clonedAsset;
    // const { policy = AssetPublishPolicy.clone } = publishConfig || {};
    // switch (policy) {
    //   case AssetPublishPolicy.authorize:
    //     break;
    //   case AssetPublishPolicy.clone:
    //     break;
    //   case AssetPublishPolicy.createNew:
    //     break;
    //   default:
    //     break;
    // }
  }

  public async updatePublishedAsset(teamId: string, assetId: string, newAssetData: BaseAssetEntity) {
    const asset = await this.getAssetById(assetId, {
      isPublished: true,
    });
    if (!asset) {
      throw new Error('资产不存在');
    }
    if (asset.teamId != teamId) {
      throw new Error('无权限操作此资产');
    }
    const { isPublished } = asset;
    if (!isPublished) {
      throw new Error('此资产未发布');
    }
    const newAsset = {
      ...asset,
      ..._.omit(newAssetData, ['assetType', 'teamId', 'creatorUserId', 'isPreset', 'isPublished', 'id', 'createdTimestamp', 'updatedTimestamp', 'isDeleted']),
      updatedTimestamp: Date.now(),
    };
    await this.repository.save(newAsset);
    return newAsset;
  }

  public async deletePublishedAsset(teamId: string, assetId: string, soft = true) {
    const asset = await this.getAssetById(assetId, {
      isPublished: true,
    });
    if (!asset) {
      throw new Error('资产不存在');
    }
    if (asset.teamId != teamId) {
      throw new Error('无权限操作此资产');
    }
    if (!asset.isPublished) {
      throw new Error('此资产未发布');
    }
    if (soft) {
      asset.isDeleted = true;
      await this.repository.save(asset);
    } else {
      await this.repository.remove(asset);
    }
    return true;
  }

  public async initBuiltInMarketPlace(assetType: AssetType, data: Partial<E>) {
    if (!data.id) {
      throw new Error('id is required to init built-in asset');
    }
    if (!data.displayName) {
      throw new Error('displayName is required to init built-in asset');
    }
    const asset = this.repository.create(data as E);
    asset.isPreset = data.isPreset || false;
    asset.isPublished = true;
    asset.assetType = assetType;
    await this.repository.save(asset);
    return asset;
  }

  public async forkBuiltInWorkflowAssetsFromMarketPlace(teamId: string, creatorUserId: string, extraDataFunc?: (e: E) => { [x: string]: any }) {
    const presetAssets = await this.repository.find({
      where: {
        isPreset: true,
      } as FindOptionsWhere<E>,
    });

    const clonedAssets: E[] = [];
    for (const asset of presetAssets) {
      const { id } = asset;
      const extraData = extraDataFunc ? extraDataFunc(asset) : {};
      const clonedAsset = this.repository.create({
        ...asset,
        ...extraData,
        id: generateDbId(),
        teamId,
        creatorUserId,
        forkFromId: id,
        isDeleted: false,
        isPreset: false,
        isPublished: false,
        createdTimestamp: Date.now(),
        updatedTimestamp: Date.now(),
      });
      await this.repository.save(clonedAsset);
      clonedAssets.push({ ...clonedAsset, forkFromId: id });
    }
    return clonedAssets;
  }
}

================================================================================

repositories/assets-canvas.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CanvasApplicationEntity } from '../entities/assets/canvas/canvas';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class CanvasAssetRepositroy extends AbstractAssetRepository<CanvasApplicationEntity> {
  constructor(
    @InjectRepository(CanvasApplicationEntity)
    public readonly assetRepository: Repository<CanvasApplicationEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-comfyui-model-type.repositor.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ComfyuiModelTypeEntity } from '../entities/assets/model/comfyui-model/comfyui-model-type.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class ComfyuiModelTypeAssetRepositroy extends AbstractAssetRepository<ComfyuiModelTypeEntity> {
  constructor(
    @InjectRepository(ComfyuiModelTypeEntity)
    public readonly assetRepository: Repository<ComfyuiModelTypeEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-comfyui-model.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ComfyuiModelEntity } from '../entities/assets/model/comfyui-model/comfyui-model.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class ComfyuiModelAssetRepositroy extends AbstractAssetRepository<ComfyuiModelEntity> {
  constructor(
    @InjectRepository(ComfyuiModelEntity)
    public readonly assetRepository: Repository<ComfyuiModelEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-comfyui-workflow.respository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ComfyuiWorkflowEntity } from '../entities/comfyui/comfyui-workflow.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class ComfyuiWorkflowAssetRepositroy extends AbstractAssetRepository<ComfyuiWorkflowEntity> {
  constructor(
    @InjectRepository(ComfyuiWorkflowEntity)
    public readonly assetRepository: Repository<ComfyuiWorkflowEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-common.repository.ts:
--------------------------------------------------------------------------------
import { AssetWithAdditionalInfo, TargetType } from '@/common/typings/asset';
import { generateDbId } from '@/common/utils';
import { getPublicProfile } from '@/common/utils/user';
import { CreateAssetFilterDto } from '@/modules/assets/req/create-asset-filter.dto';
import { UpdateAssetFilterDto } from '@/modules/assets/req/update-asset-filter.dto';
import { AssetType } from '@inf-monkeys/monkeys';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { isNil, pickBy, uniq } from 'lodash';
import { pinyin } from 'pinyin-pro';
import { DeepPartial, In, Repository } from 'typeorm';
import { AssetsAuthorizationEntity } from '../entities/assets/asset-authorization';
import { AssetFilterEntity } from '../entities/assets/asset-filter';
import { AssetsMarketPlaceTagEntity } from '../entities/assets/asset-marketplace-tag';
import { AssetsMarketplaceTagRelationsEntity } from '../entities/assets/asset-marketplace-tag-relations';
import { AssetsTagEntity } from '../entities/assets/asset-tag-definitions';
import { AssetsTagRelationsEntity } from '../entities/assets/asset-tag-relations';
import { BaseAssetEntity } from '../entities/assets/base-asset';
import { TeamRepository } from './team.repository';
import { UserRepository } from './user.repository';

export interface AssetsFillAdditionalInfoOptions {
  withUser?: boolean;
  withTeam?: boolean;
  withTags?: boolean;

  isMarketplace?: boolean;
}

@Injectable()
export class AssetsCommonRepository {
  constructor(
    @InjectRepository(AssetFilterEntity)
    private readonly assetsFilterRepository: Repository<AssetFilterEntity>,
    @InjectRepository(AssetsTagEntity)
    private readonly assetTagRepo: Repository<AssetsTagEntity>,
    @InjectRepository(AssetsTagRelationsEntity)
    private readonly assetsTagRelationsRepo: Repository<AssetsTagRelationsEntity>,
    @InjectRepository(AssetsMarketPlaceTagEntity)
    private readonly assetMarketPlaceTagRepo: Repository<AssetsMarketPlaceTagEntity>,
    @InjectRepository(AssetsMarketplaceTagRelationsEntity)
    private readonly assetsMarketPlaceTagRelationsRepo: Repository<AssetsMarketplaceTagRelationsEntity>,
    @InjectRepository(AssetsAuthorizationEntity)
    private readonly assetsAuthorizationRepository: Repository<AssetsAuthorizationEntity>,
    private readonly userRepository: UserRepository,
    private readonly teamRepository: TeamRepository,
  ) {}

  public async listFilters(teamId: string, assetType: AssetType) {
    const data = await this.assetsFilterRepository.find({
      where: {
        teamId: teamId,
        assetType: assetType,
        isDeleted: false,
      },
    });
    return data;
  }

  public async createAssetFilter(teamId: string, userId: string, body: CreateAssetFilterDto) {
    const { name, type, rules } = body;
    const data: AssetFilterEntity = {
      id: generateDbId(),
      teamId,
      creatorUserId: userId,
      name,
      assetType: type,
      rules,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      isDeleted: false,
    };
    await this.assetsFilterRepository.save(data);
    return data;
  }

  public async updateAssetFilter(teamId: string, filterId: string, updates: UpdateAssetFilterDto) {
    await this.assetsFilterRepository.update(
      {
        id: filterId,
        teamId: teamId,
        isDeleted: false,
      },
      {
        ...pickBy(updates, (v) => !isNil(v)),
        updatedTimestamp: Date.now(),
      },
    );
    return await this.assetsFilterRepository.findOne({
      where: {
        id: filterId,
        teamId: teamId,
        isDeleted: false,
      },
    });
  }

  public async deleteAssetFilter(teamId: string, filterId: string) {
    await this.assetsFilterRepository.update(
      {
        id: filterId,
        teamId,
        isDeleted: false,
      },
      {
        isDeleted: true,
        updatedTimestamp: Date.now(),
      },
    );

    return true;
  }

  public async listTags(teamId: string) {
    return await this.assetTagRepo.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });
  }

  public async createTag(teamId: string, name: string, color?: string) {
    if (typeof name !== 'string' || !name.trim()) {
      throw new Error('请输入标签名称');
    }
    const exists = await this.assetTagRepo.findOne({
      where: {
        teamId,
        name,
        isDeleted: false,
      },
    });
    if (exists) {
      return exists;
    }
    const entity = {
      id: generateDbId(),
      isDeleted: false,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      teamId,
      name,
      color,
      _pinyin: pinyin(name, { toneType: 'none' }).replace(/\s/g, ''),
    };
    await this.assetTagRepo.save(entity);
    return entity;
  }

  public async updateTag(
    teamId: string,
    tagId: string,
    updates: {
      name?: string;
      color?: string;
    },
  ) {
    const { name, color } = updates;
    const exists = await this.assetTagRepo.findOne({
      where: {
        teamId,
        id: tagId,
        isDeleted: false,
      },
    });
    if (!exists) {
      throw new Error('tag 不存在');
    }

    if (updates.name && updates.name !== exists.name) {
      const nameConfilct = await this.assetTagRepo.exists({
        where: {
          teamId,
          name,
          isDeleted: false,
        },
      });
      if (nameConfilct) {
        throw new Error('同名 tag 已存在');
      }
    }

    const toUpdates: DeepPartial<AssetsTagEntity> = {
      updatedTimestamp: Date.now(),
    };
    if (updates.name) {
      toUpdates.name = name;
      toUpdates._pinyin = pinyin(name, { toneType: 'none' }).replace(/\s/g, '');
    }
    if (updates.color) {
      toUpdates.color = color;
    }

    await this.assetTagRepo.update(
      {
        id: tagId,
      },
      toUpdates,
    );
  }

  public async deleteTag(teamId: string, tagId: string) {
    await this.assetTagRepo.update(
      {
        teamId,
        id: tagId,
      },
      {
        isDeleted: true,
      },
    );
  }

  public async updateAssetTags(teamId: string, assetType: AssetType, assetId: string, tagIds: string[]) {
    const originalTags = await this.assetsTagRelationsRepo.find({
      where: {
        isDeleted: false,
        assetType,
        assetId,
      },
    });
    const originalTagIds = originalTags.map((x) => x.tagId);
    const toDelete = originalTags.filter((x) => !tagIds.includes(x.tagId));
    const toAdd = tagIds.filter((x) => !originalTagIds.includes(x));
    for (const tag of toDelete) {
      await this.assetsTagRelationsRepo.update(
        {
          id: tag.id,
        },
        {
          isDeleted: true,
        },
      );
    }
    for (const tagId of toAdd) {
      await this.assetsTagRelationsRepo.save({
        id: generateDbId(),
        isDeleted: false,
        createdTimestamp: Date.now(),
        updatedTimestamp: Date.now(),
        teamId,
        assetType,
        assetId,
        tagId,
      });
    }
  }

  public async removeAssetTags(teamId: string, assetType: AssetType, assetId: string, tagIds: string[]) {
    if (tagIds.length) {
      await this.assetsTagRelationsRepo.update(
        {
          teamId,
          assetType,
          assetId,
        },
        {
          isDeleted: true,
        },
      );
    }
  }

  public async findAssetIdsByTagIds(assetType: AssetType, tagIds: string[]) {
    if (!tagIds.length) {
      return [];
    }
    return (
      await this.assetsTagRelationsRepo.find({
        where: {
          assetType,
          tagId: In(tagIds),
          isDeleted: false,
        },
        select: ['assetId'],
      })
    ).map((x) => x.assetId);
  }

  public async updateAssetMarketplaceTags(assetType: AssetType, assetId: string, tagIds: string[]) {
    const originalTags = await this.assetsMarketPlaceTagRelationsRepo.find({
      where: {
        isDeleted: false,
        assetType,
        assetId,
      },
    });
    const originalTagIds = originalTags.map((x) => x.tagId);
    const toDelete = originalTags.filter((x) => !tagIds.includes(x.tagId));
    const toAdd = tagIds.filter((x) => !originalTagIds.includes(x));
    for (const tag of toDelete) {
      await this.assetsMarketPlaceTagRelationsRepo.update(
        {
          id: tag.id,
        },
        {
          isDeleted: true,
        },
      );
    }
    for (const tagId of toAdd) {
      await this.assetsMarketPlaceTagRelationsRepo.save({
        id: generateDbId(),
        isDeleted: false,
        createdTimestamp: Date.now(),
        updatedTimestamp: Date.now(),
        assetType,
        assetId,
        tagId,
      });
    }
  }

  public async removeAssetMarketplaceTags(assetType: AssetType, assetId: string, tagIds: string[]) {
    if (tagIds.length) {
      await this.assetsMarketPlaceTagRelationsRepo.update(
        {
          assetType,
          assetId,
        },
        {
          isDeleted: true,
        },
      );
    }
  }

  public async findAssetIdsByMarketplaceTagIds(assetType: AssetType, tagIds: string[]) {
    if (!tagIds.length) {
      return [];
    }
    return (
      await this.assetsMarketPlaceTagRelationsRepo.find({
        where: {
          assetType,
          tagId: In(tagIds),
          isDeleted: false,
        },
        select: ['assetId'],
      })
    ).map((x) => x.assetId);
  }

  public async fillAdditionalInfo<E extends BaseAssetEntity>(item: E, options?: AssetsFillAdditionalInfoOptions): Promise<AssetWithAdditionalInfo<E>> {
    const { withTeam = false, withUser = false, withTags = false } = options || {};
    const result: AssetWithAdditionalInfo<E> = {
      ...item,
    };
    if (!item) return null;
    const { teamId, creatorUserId } = item as E;

    if (withUser) {
      if (creatorUserId) {
        const user = await this.userRepository.findById(creatorUserId);
        if (user) {
          const userProfile = getPublicProfile(user);
          result.user = userProfile;
        } else {
          result.user = {};
        }
      } else {
        result.user = {};
      }
    }

    if (withTeam) {
      const teamProfile = await this.teamRepository.getTeamById(teamId);
      result.team = teamProfile;
    }

    if (withTags) {
      const tagIds = (
        await this.assetsTagRelationsRepo.find({
          where: {
            assetType: item.assetType,
            assetId: item.getAssetId(),
            isDeleted: false,
          },
        })
      ).map((x) => x.tagId);
      result.assetTags = await this.assetTagRepo.find({
        where: {
          id: In(tagIds),
        },
      });
    }

    return result;
  }

  public async fillAdditionalInfoList<E extends BaseAssetEntity>(list: E[], options?: AssetsFillAdditionalInfoOptions): Promise<AssetWithAdditionalInfo<E>[]> {
    const { withTeam = false, withUser = false, withTags = false, isMarketplace = false } = options || {};

    const teamIds = uniq((list as E[]).map((l) => l.teamId).filter((l) => l));
    const userIds = uniq((list as E[]).map((l) => l.creatorUserId).filter((l) => l));
    const assetIds = uniq(list.map((l) => l.getAssetId()).flat());

    const assetIdToTags: { [x: string]: (AssetsTagEntity | AssetsMarketPlaceTagEntity)[] } = {};

    if (withTags) {
      const tagsWheres = list.map((x) => ({
        assetType: x.assetType,
        assetId: x.getAssetId(),
        isDeleted: false,
      }));
      const allTagRels =
        withTags && assetIds.length
          ? (await this?.[isMarketplace ? 'assetsMarketPlaceTagRelationsRepo' : 'assetsTagRelationsRepo'].find({
              where: tagsWheres,
            })) || []
          : [];
      const allTagIds = uniq(allTagRels.map((x) => x.tagId));
      const allTagDefs =
        withTags && allTagIds.length
          ? (await this?.[isMarketplace ? 'assetMarketPlaceTagRepo' : 'assetTagRepo'].find({
              where: {
                id: In(allTagIds),
              },
            })) || []
          : [];
      for (const item of list) {
        const itemTagIds = allTagRels.filter((x) => x.assetId === item.getAssetId()).map((x) => x.tagId);
        assetIdToTags[item.getAssetId()] = allTagDefs.filter((x) => itemTagIds.includes(x.id));
      }
    }

    const teamHash = withTeam ? await this.teamRepository.getTeamsByIdsAsMap(teamIds) : null;
    const userHash = withTeam ? await this.userRepository.getUsersByIdsAsMap(userIds) : null;

    const result: Array<AssetWithAdditionalInfo<E>> = [];
    for (const originalItem of list) {
      const item: AssetWithAdditionalInfo<E> = {
        ...originalItem,
      };
      if (withUser) {
        item.user = userHash?.[originalItem.creatorUserId] ? getPublicProfile(userHash?.[originalItem.creatorUserId]) : {};
      }
      if (withTeam) {
        item.team = teamHash?.[originalItem.teamId] ?? {};
      }
      if (withTags) {
        item.assetTags = assetIdToTags[originalItem.getAssetId()];
      }
      result.push(item);
    }
    return result;
  }

  public async listAuthorizedAssetIds(teamId: string, assetType: AssetType) {
    return (
      await this.assetsAuthorizationRepository.find({
        where: {
          targetType: TargetType.TEAM,
          targetId: teamId,
          assetType,
          isDeleted: false,
        },
        select: ['assetId'],
      })
    ).map((x) => x.assetId);
  }

  public async createMarketplaceTag(assetType: AssetType, name: string) {
    if (typeof name !== 'string' || !name.trim()) {
      throw new Error('请输入标签名称');
    }
    const exists = await this.assetMarketPlaceTagRepo.findOne({
      where: {
        name,
        isDeleted: false,
      },
    });
    if (exists) {
      return exists;
    }
    const entity = {
      id: generateDbId(),
      isDeleted: false,
      assetType,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      name,
      _pinyin: pinyin(name, { toneType: 'none' }).replace(/\s/g, ''),
    };
    await this.assetMarketPlaceTagRepo.save(entity);
    return entity;
  }

  public async createMarketplaceTagBatch(assetType: AssetType, tags: string[]) {
    const result: AssetsMarketPlaceTagEntity[] = [];
    for (const tag of tags) {
      const item = await this.createMarketplaceTag(assetType, tag);
      result.push(item);
    }
    return result;
  }

  public async listMarketplaceTags(assetType: AssetType) {
    return await this.assetMarketPlaceTagRepo.find({
      where: {
        assetType,
        isDeleted: false,
      },
    });
  }
}

================================================================================

repositories/assets-conversation-app.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ConversationAppEntity } from '../entities/conversation-app/conversation-app.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class ConversationAppAssetRepositroy extends AbstractAssetRepository<ConversationAppEntity> {
  constructor(
    @InjectRepository(ConversationAppEntity)
    public readonly assetRepository: Repository<ConversationAppEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-knowledge-base-sql.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SqlKnowLedgeBaseEntity } from '../entities/assets/knowledge-base/knowledge-base-sql.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class SqlKnowledgeBaseAssetRepositroy extends AbstractAssetRepository<SqlKnowLedgeBaseEntity> {
  constructor(
    @InjectRepository(SqlKnowLedgeBaseEntity)
    public readonly assetRepository: Repository<SqlKnowLedgeBaseEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-knowledge-base.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { KnowLedgeBaseEntity } from '../entities/assets/knowledge-base/knowledge-base.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class KnowledgeBaseAssetRepositroy extends AbstractAssetRepository<KnowLedgeBaseEntity> {
  constructor(
    @InjectRepository(KnowLedgeBaseEntity)
    public readonly assetRepository: Repository<KnowLedgeBaseEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-llm-channel.respository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { LlmChannelEntity } from '../entities/assets/model/llm-channel/llm-channel.entity';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class LlmChannelAssetRepositroy extends AbstractAssetRepository<LlmChannelEntity> {
  constructor(
    @InjectRepository(LlmChannelEntity)
    public readonly assetRepository: Repository<LlmChannelEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-llm-model.respository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { LlmModelEntity } from '../entities/assets/model/llm-model/llm-model';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class LlmModelAssetRepositroy extends AbstractAssetRepository<LlmModelEntity> {
  constructor(
    @InjectRepository(LlmModelEntity)
    public readonly assetRepository: Repository<LlmModelEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-marketplace.repository.ts:
--------------------------------------------------------------------------------
import { LlmModelEndpointType } from '@/common/config';
import { generateDbId, getComfyuiWorkflowDataListFromWorkflow } from '@/common/utils';
import { WorkflowPageGroupEntity } from '@/database/entities/workflow/workflow-page-group';
import { BUILT_IN_WORKFLOW_MARKETPLACE_LIST, PAGE_GROUP_SORT_LIST } from '@/modules/assets/assets.marketplace.data';
import { LLM_CHAT_COMPLETION_TOOL, LLM_COMPLETION_TOOL, LLM_GENERATE_TEXT_TOOL, LLM_NAMESPACE } from '@/modules/tools/llm/llm.controller';
import { getDefaultModel } from '@/modules/tools/llm/llm.service';
import { SimpleTaskDef } from '@inf-monkeys/conductor-javascript';
import { Injectable } from '@nestjs/common';
import _, { uniq } from 'lodash';
import { ComfyuiWorkflowEntity } from '../entities/comfyui/comfyui-workflow.entity';
import { WorkflowMetadataEntity } from '../entities/workflow/workflow-metadata';
import { ComfyuiWorkflowAssetRepositroy } from './assets-comfyui-workflow.respository';
import { WorkflowAssetRepositroy } from './assets-workflow.respository';
import { WorkflowRepository } from './workflow.repository';

@Injectable()
export class AssetsMarketPlaceRepository {
  constructor(
    private readonly workflowAssetsRepository: WorkflowAssetRepositroy,
    private readonly workflowRepository: WorkflowRepository,
    private readonly comfyuiWorkflowAssetsRepositroy: ComfyuiWorkflowAssetRepositroy,
  ) { }

  public async forkBuiltInWorkflowAssetsFromMarketPlace(
    teamId: string,
    creatorUserId: string,
    extraOptions?: {
      clonedComfyuiWorkflows: (ComfyuiWorkflowEntity & { forkFromId: string })[];
    },
  ) {
    const clonedWorkflows = await this.workflowAssetsRepository.forkBuiltInWorkflowAssetsFromMarketPlace(teamId, creatorUserId, (workflowMetadata: WorkflowMetadataEntity) => {
      const { tasks = [] } = workflowMetadata;
      const comfyuiDataList = getComfyuiWorkflowDataListFromWorkflow(tasks);
      const comfyuiWorkflowIdMapper = extraOptions.clonedComfyuiWorkflows.reduce((mapper, cw) => {
        mapper[cw.forkFromId] = cw.id;
        return mapper;
      }, {});
      for (const task of tasks) {
        if (task.name === `${LLM_NAMESPACE}:${LLM_CHAT_COMPLETION_TOOL}`) {
          const defaultModel = getDefaultModel(LlmModelEndpointType.CHAT_COMPLETIONS);
          if (defaultModel) {
            (task as SimpleTaskDef).inputParameters.model = defaultModel;
          }
        } else if (task.name === `${LLM_NAMESPACE}:${LLM_COMPLETION_TOOL}`) {
          const defaultModel = getDefaultModel(LlmModelEndpointType.COMPLITIONS);
          if (defaultModel) {
            (task as SimpleTaskDef).inputParameters.model = defaultModel;
          }
        } else if (task.name === `${LLM_NAMESPACE}:${LLM_GENERATE_TEXT_TOOL}`) {
          const defaultModel = getDefaultModel(LlmModelEndpointType.CHAT_COMPLETIONS);
          if (defaultModel) {
            (task as SimpleTaskDef).inputParameters.model = defaultModel;
          }
        }
      }
      for (const { path, comfyuiWorkflowId } of comfyuiDataList) {
        _.set(tasks, `${path}.workflow`, comfyuiWorkflowIdMapper[comfyuiWorkflowId]);
        _.set(tasks, `${path}.server`, 'system');
      }
      return {
        workflowId: generateDbId(),
      };
    });

    const pageIdOrderMap = new Map<string, number>();

    for (const workflow of clonedWorkflows) {
      const { forkFromId } = workflow;
      const originalMarketPlaceData = BUILT_IN_WORKFLOW_MARKETPLACE_LIST.find((x) => x.id === forkFromId);
      if (originalMarketPlaceData?.autoPinPage?.length) {
        const pages = await this.workflowRepository.listWorkflowPagesAndCreateIfNotExists(workflow.workflowId);

        const groupMap: Record<string, WorkflowPageGroupEntity> = {};
        const groups = uniq(originalMarketPlaceData.autoPinPage.flatMap((it) => Object.keys(it)));
        const groupIds = await this.workflowRepository.getPageGroupsAndCreateIfNotExists(teamId, groups);
        let groupIndex = 0;
        for (const group of groupIds) {
          groupMap[groups[groupIndex]] = group;
          groupIndex++;
        }

        for (const mapper of originalMarketPlaceData.autoPinPage) {
          for (const [groupName, pageTypes] of Object.entries(mapper)) {
            const type2PageIds = pages.filter((it) => pageTypes.includes(it.type)).map((it) => it.id);
            type2PageIds.forEach((pageId) => {
              pageIdOrderMap.set(pageId, PAGE_GROUP_SORT_LIST.indexOf(forkFromId) || 100000);
            });
            groupMap[groupName].pageIds = uniq([...(groupMap[groupName].pageIds ?? []), ...type2PageIds]).sort((a, b) => {
              return pageIdOrderMap.get(a) - pageIdOrderMap.get(b);
            });
          }
        }

        for (const group of Object.values(groupMap)) {
          await this.workflowRepository.updatePageGroup(group.id, { pageIds: group.pageIds });
        }
      }
    }
    return clonedWorkflows;
  }

  public async forkBuiltInComfyuiWorkflowAssetsFromMarketPlace(teamId: string, creatorUserId: string) {
    return await this.comfyuiWorkflowAssetsRepositroy.forkBuiltInWorkflowAssetsFromMarketPlace(teamId, creatorUserId);
  }
}

================================================================================

repositories/assets-media-file.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { MediaFileEntity } from '../entities/assets/media/media-file';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class MediaFileAssetRepositroy extends AbstractAssetRepository<MediaFileEntity> {
  constructor(
    @InjectRepository(MediaFileEntity)
    public readonly assetRepository: Repository<MediaFileEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-sd-model.repository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SdModelEntity } from '../entities/assets/model/sd-model/sd-model';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class SdModelAssetRepositroy extends AbstractAssetRepository<SdModelEntity> {
  constructor(
    @InjectRepository(SdModelEntity)
    public readonly assetRepository: Repository<SdModelEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/assets-workflow.respository.ts:
--------------------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { WorkflowMetadataEntity } from '../entities/workflow/workflow-metadata';
import { AbstractAssetRepository } from './assets-abstract.repository';
import { AssetsCommonRepository } from './assets-common.repository';

@Injectable()
export class WorkflowAssetRepositroy extends AbstractAssetRepository<WorkflowMetadataEntity> {
  constructor(
    @InjectRepository(WorkflowMetadataEntity)
    public readonly assetRepository: Repository<WorkflowMetadataEntity>,
    public readonly assetCommonRepository: AssetsCommonRepository,
  ) {
    super(assetRepository, assetCommonRepository);
  }
}

================================================================================

repositories/comfyui-model.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { generateDbId, maskUrl } from '@/common/utils';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import _, { set } from 'lodash';
import { ILike, In, Repository } from 'typeorm';
import { ComfyuiModelServerRelationEntity } from '../entities/assets/model/comfyui-model/comfyui-model-server-relation.entity';
import { ComfyuiModelTypeEntity, CreateComfyuiModelTypeParams, UpdateComfyuiModelTypeParams } from '../entities/assets/model/comfyui-model/comfyui-model-type.entity';
import { ComfyuiModelEntity, CreateComfyuiModelParams, UpdateComfyuiModelParams } from '../entities/assets/model/comfyui-model/comfyui-model.entity';
import { ComfyuiModelTypeAssetRepositroy } from './assets-comfyui-model-type.repositor';
import { ComfyuiModelAssetRepositroy } from './assets-comfyui-model.repository';

@Injectable()
export class ComfyuiModelRepository {
  constructor(
    @InjectRepository(ComfyuiModelEntity)
    private readonly modelRepository: Repository<ComfyuiModelEntity>,
    private readonly modelAssetRepository: ComfyuiModelAssetRepositroy,
    @InjectRepository(ComfyuiModelTypeEntity)
    private readonly modelTypeRepository: Repository<ComfyuiModelTypeEntity>,
    private readonly modelTypeAssetRepository: ComfyuiModelTypeAssetRepositroy,
    @InjectRepository(ComfyuiModelServerRelationEntity)
    private readonly relationRepository: Repository<ComfyuiModelServerRelationEntity>,
  ) { }

  public async listAssetTypes(teamId: string, dto: ListDto) {
    return await this.modelTypeAssetRepository.listAssets('comfyui-model-type', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }

  public async listTypes(teamId: string) {
    return await this.modelTypeRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });
  }

  public async createType(teamId: string, userId: string, params: CreateComfyuiModelTypeParams) {
    const { path, name } = params;

    if (!path || !name) {
      throw new Error('path and name are required');
    }

    const entity = new ComfyuiModelTypeEntity();
    entity.id = generateDbId();
    entity.displayName = params.displayName || params.name;
    entity.description = params.description || '';
    entity.teamId = teamId;
    entity.creatorUserId = userId;
    entity.createdTimestamp = +new Date();
    entity.updatedTimestamp = +new Date();
    entity.isDeleted = false;
    entity.path = path;
    entity.name = name;
    return await this.modelTypeRepository.save(entity);
  }

  public async getTypeById(teamId: string, id: string) {
    return await this.modelTypeRepository.findOne({
      where: {
        id,
        teamId,
        isDeleted: false,
      },
    });
  }

  public async getTypeByName(teamId: string, name: string) {
    return await this.modelTypeRepository.findOne({
      where: {
        name,
        teamId,
        isDeleted: false,
      },
    });
  }

  public async getTypeByPath(teamId: string, path: string) {
    return await this.modelTypeRepository.findOne({
      where: {
        path,
        teamId,
        isDeleted: false,
      },
    });
  }

  public async updateType(teamId: string, id: string, updates: UpdateComfyuiModelTypeParams) {
    const entity = await this.getTypeById(teamId, id);
    if (!entity) throw new Error('ComfyUI model type not found');

    if (updates.displayName) entity.displayName = updates.displayName;
    if (updates.description) entity.description = updates.description;
    if (updates.name) entity.name = updates.name;
    if (updates.path) entity.path = updates.path;

    entity.updatedTimestamp = Date.now();
    return await this.modelTypeRepository.save(entity);
  }

  public async deleteType(teamId: string, id: string) {
    const entity = await this.getTypeById(teamId, id);
    if (!entity) {
      return;
    }
    entity.isDeleted = true;
    entity.updatedTimestamp = Date.now();
    await this.modelTypeRepository.save(entity);
  }

  public async updateTypesFromTeamIdToTeamId(originTeamId: string, targetTeamId: string) {
    const originTypes = await this.listTypes(originTeamId);
    const targetTypes = await this.listTypes(targetTeamId);

    const originTypeNameList = originTypes.map((t) => t.name);
    const targetTypeNameList = targetTypes.map((t) => t.name);

    // update
    const toUpdate = targetTypes
      .filter((t) => originTypeNameList.includes(t.name))
      .map((t) => {
        const newParams = _.pick(originTypes.find((ot) => ot.name === t.name) ?? {}, ['displayName', 'description', 'path']);
        return {
          ...t,
          ...newParams,
        };
      });
    toUpdate.forEach(async (t) => {
      await this.updateType(targetTeamId, t.id, t);
    });

    // remove
    const toRemove = targetTypes.filter((t) => !originTypeNameList.includes(t.name));
    const toRemoveResult = await this.modelTypeRepository.remove(toRemove);

    // create
    const toCreate = originTypes.filter((t) => !targetTypeNameList.includes(t.name));
    toCreate.forEach(async (t) => {
      await this.createType(targetTeamId, t.creatorUserId, _.pick(t, ['name', 'description', 'displayName', 'path']));
    });

    return {
      remove: toRemoveResult.length,
      update: toUpdate.length,
      create: toCreate.length,
    };
  }

  public async listModels(teamId: string, dto: ListDto) {
    const rawModels = await this.modelAssetRepository.listAssets(
      'comfyui-model',
      teamId,
      dto,
      {
        withTags: true,
        withTeam: true,
        withUser: true,
      },
      {
        relations: {
          serverRelations: {
            server: true,
          },
        },
      },
      {
        serverRelations: {
          server: {
            isDeleted: false,
          },
        },
      },
    );
    const modelTypes = await this.modelTypeRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });

    const list = rawModels.list.map((model) => {
      const { serverRelations } = model;
      return {
        ...model,
        serverRelations: serverRelations
          ? serverRelations.map((relation) => {
            set(relation, 'server.address', maskUrl(relation.server.address));
            return {
              ...relation,
              type: modelTypes.filter((type) => relation.path.toLowerCase().startsWith(type.path.toLowerCase())),
            };
          })
          : undefined,
      };
    });
    return {
      ...rawModels,
      list,
    };
  }

  public async getModelsWithoutType() {
    return await this.modelRepository.find({
      where: {
        isDeleted: false,
      },
      relations: {
        serverRelations: {
          server: true,
        },
      },
    });
  }

  public async getModelsByTeamId(teamId: string) {
    const rawModels = await this.modelRepository.find({
      where:
        teamId === 'internals'
          ? {
            teamId,
            isDeleted: false,
          }
          : {
            teamId,
            isDeleted: false,
            serverRelations: {
              server: {
                isDeleted: false,
              },
            },
          },
      relations: {
        serverRelations: {
          server: true,
        },
      },
    });
    const modelTypes = await this.modelTypeRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });

    const list = rawModels.map((model) => {
      const { serverRelations } = model;
      return {
        ...model,
        serverRelations: serverRelations
          ? serverRelations.map((relation) => {
            return {
              ...relation,
              type: modelTypes.filter((type) => relation.path.toLowerCase().startsWith(type.path.toLowerCase())),
            };
          })
          : undefined,
      };
    });
    return list;
  }

  public async getModelsByServerId(teamId: string, serverId: string) {
    const rawModels = await this.modelRepository.find({
      where: {
        teamId,
        serverRelations: {
          server: {
            id: In([serverId]),
            isDeleted: false,
          },
        },
        isDeleted: false,
      },
      relations: {
        serverRelations: {
          server: true,
        },
      },
    });
    const modelTypes = await this.modelTypeRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });

    return rawModels.map((model) => {
      const { serverRelations } = model;
      return {
        ...model,
        serverRelations: serverRelations
          ? serverRelations.map((relation) => {
            return {
              ...relation,
              type: modelTypes.filter((type) => relation.path.toLowerCase().startsWith(type.path.toLowerCase())),
            };
          })
          : undefined,
      };
    });
  }

  public async getModelsByTypeAndServerId(teamId: string, serverId: string, typeInfo: { typeId?: string; typeName?: string }) {
    const modelType = typeInfo.typeId ? await this.getTypeById(teamId, typeInfo.typeId) : typeInfo.typeName && (await this.getTypeByName(teamId, typeInfo.typeName));
    if (!modelType) throw new Error('Model type not found');

    const rawModels = await this.modelRepository.find({
      where: {
        teamId,
        serverRelations: {
          server: {
            id: In([serverId]),
            isDeleted: false,
          },
          path: ILike(`${modelType.path}%`),
        },
        isDeleted: false,
      },
      relations: {
        serverRelations: {
          server: true,
        },
      },
    });

    const modelTypes = await this.modelTypeRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });

    return rawModels.map((model) => {
      const { serverRelations } = model;
      return {
        ...model,
        serverRelations: serverRelations
          ? serverRelations.map((relation) => {
            const pathArr = relation.path.split('/');
            set(relation, 'server.address', maskUrl(relation.server.address));
            return {
              ...relation,
              apiPath: pathArr.length > 1 ? pathArr.slice(1).join('/') : relation.path,
              type: modelTypes.filter((type) => relation.path.toLowerCase().startsWith(type.path.toLowerCase())),
            };
          })
          : undefined,
      };
    });
  }

  public async getModelsBySha256List(teamId: string, sha256List: string[]) {
    return await this.modelRepository.find({ where: { sha256: In(sha256List), teamId, isDeleted: false } });
  }

  public async getModelById(teamId: string, modelId: string) {
    const rawModel = await this.modelRepository.findOne({
      where: [
        {
          teamId,
          id: modelId,
          isDeleted: false,
          serverRelations: {
            server: {
              isDeleted: false,
            },
          },
        },
        {
          teamId,
          id: modelId,
          isDeleted: false,
          serverRelations: null,
        },
      ],
      relations: {
        serverRelations: {
          server: true,
        },
      },
    });

    if (!rawModel) throw new Error('ComfyUI model not found');

    const modelTypes = await this.modelTypeRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });

    if (rawModel.serverRelations) {
      rawModel.serverRelations = rawModel.serverRelations.map((relation) => {
        set(relation, 'server.address', maskUrl(relation.server.address));
        return {
          ...relation,
          type: modelTypes.filter((type) => relation.path.toLowerCase().startsWith(type.path.toLowerCase())),
        };
      });
    }

    return rawModel;
  }

  public async createModel(teamId: string, params: CreateComfyuiModelParams) {
    const { sha256 } = params;

    if (!sha256) throw new Error('path and sha256 are required');

    const entity = new ComfyuiModelEntity();
    entity.id = params.id || generateDbId();
    entity.displayName = params.displayName || '';
    entity.description = params.description || '';
    entity.teamId = teamId;
    entity.createdTimestamp = +new Date();
    entity.updatedTimestamp = +new Date();
    entity.isDeleted = false;
    entity.sha256 = sha256;
    entity.serverRelations = params.serverRelations || [];
    return await this.modelRepository.save(entity);
  }

  public async createModels(teamId: string, params: CreateComfyuiModelParams[]) {
    const r: ComfyuiModelEntity[] = [];
    for (const p of params) {
      r.push(await this.createModel(teamId, p));
    }
    return r;
  }

  public async saveModel(model: Pick<ComfyuiModelEntity, 'sha256' | 'id' | 'serverRelations'>) {
    return await this.modelRepository.save(model);
  }

  public async saveModels(models: Pick<ComfyuiModelEntity, 'sha256' | 'id' | 'serverRelations'>[]) {
    return await this.modelRepository.save(models);
  }

  public async updateModel(teamId: string, modelId: string, updates: UpdateComfyuiModelParams) {
    const entity = await this.getModelById(teamId, modelId);
    if (!entity) throw new Error('ComfyUI model not found');

    if (updates.displayName) entity.displayName = updates.displayName;
    if (updates.description) entity.description = updates.description;
    if (updates.iconUrl) entity.iconUrl = updates.iconUrl;

    entity.updatedTimestamp = Date.now();
    return await this.modelRepository.save(entity);
  }

  public async saveRelation(relation: ComfyuiModelServerRelationEntity) {
    return await this.relationRepository.save(relation);
  }

  public async updateModelsFromTeamIdToTeamId(originTeamId: string, targetTeamId: string) {
    // 并行获取源数据和目标数据
    const [originModels, targetModels] = await Promise.all([this.getModelsByTeamId(originTeamId), this.getModelsByTeamId(targetTeamId)]);

    // 使用 Set 提高查找效率
    const originSha256Set = new Set(originModels.map((m) => m.sha256));
    const targetSha256Set = new Set(targetModels.map((m) => m.sha256));

    console.log(originTeamId, originModels.length, targetTeamId, targetModels.length);

    // 需要更新的目标模型（SHA256 匹配的）
    const toUpdate = targetModels
      .filter((m) => originSha256Set.has(m.sha256))
      .map((m) => ({
        id: m.id,
        ..._.pick(originModels.find((om) => om.sha256 === m.sha256)!, ['displayName', 'description', 'iconUrl']),
      }));

    // 需要创建的新模型（存在于源但不在目标中的）
    const toCreate = originTeamId === 'internals' ? [] : originModels.filter((m) => !targetSha256Set.has(m.sha256));

    // 执行更新操作
    for (const model of toUpdate) {
      await this.updateModel(targetTeamId, model.id, model);
    }

    // 执行创建操作
    for (const model of toCreate) {
      await this.createModel(targetTeamId, _.pick(model, ['iconUrl', 'description', 'displayName', 'sha256']));
    }

    return {
      remove: 0, // 根据要求不执行删除操作
      update: toUpdate.length,
      create: toCreate.length,
    };
  }
}

================================================================================

repositories/comfyui.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { ComfyuiPrompt, ComfyuiWorkflow } from '@/common/typings/comfyui';
import { generateDbId } from '@/common/utils';
import { CreateComfyuiServerDto } from '@/modules/tools/comfyui/dto/req/create-comfyui-server';
import { ToolProperty } from '@inf-monkeys/monkeys';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import _ from 'lodash';
import { IsNull, Repository } from 'typeorm';
import { ComfyuiServerEntity, ComfyuiServerStatus } from '../entities/comfyui/comfyui-server.entity';
import { ComfyuiWorkflowEntity, ComfyuiWorkflowSourceType } from '../entities/comfyui/comfyui-workflow.entity';
import { ComfyuiWorkflowAssetRepositroy } from './assets-comfyui-workflow.respository';

export interface CreateComfyuiWorkflowParams {
  workflowType: ComfyuiWorkflowSourceType;
  originalData: { [x: string]: any };
  workflow?: ComfyuiWorkflow;
  prompt: ComfyuiPrompt;
  displayName: string;
  toolInput?: ToolProperty[];
  toolOutput?: ToolProperty[];
}

@Injectable()
export class ComfyuiRepository {
  constructor(
    @InjectRepository(ComfyuiWorkflowEntity)
    private readonly comfyuiWorkflowRepository: Repository<ComfyuiWorkflowEntity>,
    @InjectRepository(ComfyuiServerEntity)
    private readonly comfyuiServerRepository: Repository<ComfyuiServerEntity>,
    private readonly comfyuiWorkflowAssetsRepository: ComfyuiWorkflowAssetRepositroy,
  ) {}

  public async listComfyuiWorkflows(teamId: string, dto: ListDto) {
    return await this.comfyuiWorkflowAssetsRepository.listAssets('comfyui-workflow', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }

  public async deleteComfyuiWorkflow(id: string) {
    await this.comfyuiWorkflowRepository.update(
      {
        id,
      },
      {
        isDeleted: true,
        updatedTimestamp: +new Date(),
      },
    );
  }

  public async updateComfyuiWorkflow(
    id: string,
    updates: {
      toolInput?: ToolProperty[];
      toolOutput?: ToolProperty[];
      workflow?: ComfyuiWorkflow;
      workflowApi?: ComfyuiPrompt;
    },
  ) {
    await this.comfyuiWorkflowRepository.update(
      {
        id,
      },
      _.omitBy(
        {
          toolInput: updates.toolInput,
          toolOutput: updates.toolOutput,
          workflow: updates.workflow,
          prompt: updates.workflowApi,
          updatedTimestamp: +new Date(),
        },
        _.isNil,
      ),
    );
  }

  public async createComfyuiWorkflow(teamId: string, userId: string, comfyuiWorkflow: CreateComfyuiWorkflowParams) {
    const entity = new ComfyuiWorkflowEntity();
    entity.id = generateDbId();
    entity.createdTimestamp = +new Date();
    entity.updatedTimestamp = +new Date();
    entity.isDeleted = false;
    entity.teamId = teamId;
    entity.creatorUserId = userId;
    entity.workflowType = comfyuiWorkflow.workflowType;
    entity.originalData = comfyuiWorkflow.originalData;
    entity.workflow = comfyuiWorkflow.workflow;
    entity.prompt = comfyuiWorkflow.prompt;
    entity.displayName = comfyuiWorkflow.displayName;
    entity.toolInput = comfyuiWorkflow.toolInput || [];
    entity.toolOutput = comfyuiWorkflow.toolOutput || [];

    await this.comfyuiWorkflowRepository.save(entity);
  }

  public async getComfyuiWorkflowById(id: string) {
    return await this.comfyuiWorkflowRepository.findOne({
      where: {
        id,
        isDeleted: false,
      },
    });
  }

  public async getAllComfyuiWorkflows(teamId: string) {
    return await this.comfyuiWorkflowRepository.find({
      where: {
        isDeleted: false,
        teamId,
      },
    });
  }

  public async listServers(teamId: string) {
    return await this.comfyuiServerRepository.find({
      where: [
        {
          isDeleted: false,
          teamId: IsNull(),
        },
        {
          isDeleted: false,
          teamId,
        },
      ],
    });
  }

  public async listAllServers() {
    return await this.comfyuiServerRepository.find({
      where: {
        isDeleted: false,
      },
    });
  }

  public async createDefaultServer(address: string) {
    const exists = await this.comfyuiServerRepository.findOne({
      where: {
        isDefault: true,
        isDeleted: false,
      },
    });
    if (!exists) {
      const entity = new ComfyuiServerEntity();
      entity.id = 'default';
      entity.createdTimestamp = +new Date();
      entity.updatedTimestamp = +new Date();
      entity.isDeleted = false;
      entity.address = address;
      entity.status = ComfyuiServerStatus.Unkonwn;
      entity.description = '默认 ComfyUI Server';
      entity.isDefault = true;
      await this.comfyuiServerRepository.save(entity);
    } else {
      exists.address = address;
      await this.comfyuiServerRepository.save(exists);
    }
  }

  public async createComfyuiServer(teamId: string, userId: string, data: CreateComfyuiServerDto) {
    const entity = new ComfyuiServerEntity();
    entity.id = generateDbId();
    entity.createdTimestamp = +new Date();
    entity.updatedTimestamp = +new Date();
    entity.isDeleted = false;
    entity.teamId = teamId;
    entity.creatorUserId = userId;
    entity.address = data.address;
    entity.status = ComfyuiServerStatus.Unkonwn;
    entity.description = data.description;
    entity.isDefault = false;
    await this.comfyuiServerRepository.save(entity);
  }

  public async deleteComfyuiServer(teamId: string, address: string) {
    await this.comfyuiServerRepository.update(
      {
        teamId,
        address,
      },
      {
        isDeleted: true,
        updatedTimestamp: +new Date(),
      },
    );
  }

  public async getComfyuiServerById(teamId: string | null, serverId: string) {
    return await this.comfyuiServerRepository.findOne({
      where: {
        teamId,
        id: serverId,
      },
    });
  }
}

================================================================================

repositories/conversation-app.repository.ts:
--------------------------------------------------------------------------------
import { config, LlmModelEndpointType } from '@/common/config';
import { ListDto } from '@/common/dto/list.dto';
import { ConversationStatusEnum } from '@/common/dto/status.enum';
import { generateDbId } from '@/common/utils';
import { getModels } from '@/modules/tools/llm/llm.service';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import _ from 'lodash';
import { Repository } from 'typeorm';
import { ConversationAppEntity, CreateConversationAppParams, UpdateConversationAppParams } from '../entities/conversation-app/conversation-app.entity';
import { ConversationExecutionEntity } from '../entities/conversation-app/conversation-executions.entity';
import { ConversationAppAssetRepositroy } from './assets-conversation-app.repository';
import { LlmModelRepository } from './llm-model.repository';
import { OneApiRepository } from './oneapi.respository';

@Injectable()
export class ConversationAppRepository {
  constructor(
    @InjectRepository(ConversationAppEntity)
    private readonly repository: Repository<ConversationAppEntity>,
    @InjectRepository(ConversationExecutionEntity)
    private readonly executionRepository: Repository<ConversationExecutionEntity>,
    private readonly assetRepository: ConversationAppAssetRepositroy,
    private readonly llmModelRepository: LlmModelRepository,
    private readonly oneapiRepository: OneApiRepository,
  ) {}

  public async listConversationApps(teamId: string, dto: ListDto) {
    return await this.assetRepository.listAssets('conversation-app', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }

  private async checkModel(model: string, teamId: string): Promise<'BUILT_IN' | 'ONEAPI'> {
    const avaliableModels = getModels(LlmModelEndpointType.CHAT_COMPLETIONS).map((x) => x.value);

    const [modelChannelId, modelName] = model.split(':');
    if (!isNaN(Number(modelChannelId))) {
      const llmModel = await this.llmModelRepository.getLLMModelByChannelId(Number(modelChannelId));
      if (!Object.values(llmModel?.models ?? {}).includes(modelName) || (llmModel?.isDeleted && llmModel?.teamId !== teamId)) {
        throw new Error('Model not found !');
      }

      return 'ONEAPI';
    }

    if (!avaliableModels.includes(model)) {
      throw new Error(`Model ${model} is not available`);
    }
    return 'BUILT_IN';
  }

  private async checkCustomModelUnique(teamId: string, customModelName: string) {
    const entity = await this.repository.findOne({
      where: {
        teamId,
        customModelName,
        isDeleted: false,
      },
    });
    if (entity) {
      throw new Error('Custom model name must be unique');
    }
  }

  public async createConversationApp(teamId: string, userId: string, params: CreateConversationAppParams) {
    const { model } = params;

    if (!model) {
      throw new Error('Model is required');
    }

    await this.checkModel(model, teamId);

    if (params.customModelName) {
      await this.checkCustomModelUnique(teamId, params.customModelName);
    }

    const entity = new ConversationAppEntity();
    entity.id = generateDbId();
    entity.displayName = params.displayName;
    entity.description = params.description || '';
    entity.iconUrl = params.iconUrl || 'emoji:🍀:#ceefc5';
    entity.teamId = teamId;
    entity.creatorUserId = userId;
    entity.createdTimestamp = +new Date();
    entity.updatedTimestamp = +new Date();
    entity.isDeleted = false;
    entity.model = params.model;
    entity.systemPrompt = params.systemPrompt;
    entity.knowledgeBase = params.knowledgeBase;
    entity.sqlKnowledgeBase = params.sqlKnowledgeBase;
    entity.tools = params.tools;
    entity.temperature = params.temperature;
    entity.presence_penalty = params.presence_penalty;
    entity.frequency_penalty = params.frequency_penalty;
    entity.customModelName = params.customModelName;
    return await this.repository.save(entity);
  }

  public async getConversationAppById(teamId: string, id: string) {
    return await this.repository.findOne({
      where: {
        id,
        teamId,
        isDeleted: false,
      },
    });
  }

  public async getConversationAppByCustomModelName(teamId: string, customModelName: string) {
    return await this.repository.findOne({
      where: {
        customModelName,
        teamId,
        isDeleted: false,
      },
    });
  }

  public async deleteConversationApp(teamId: string, id: string) {
    const entity = await this.getConversationAppById(teamId, id);
    if (!entity) {
      return;
    }
    entity.isDeleted = true;
    entity.updatedTimestamp = Date.now();
    await this.repository.save(entity);
  }

  public async updateConversationApp(teamId: string, id: string, updates: UpdateConversationAppParams) {
    const entity = await this.getConversationAppById(teamId, id);
    if (!entity) {
      return null;
    }
    if (updates.displayName) {
      entity.displayName = updates.displayName;
    }
    if (updates.description != undefined) {
      entity.description = updates.description;
    }
    if (updates.iconUrl) {
      entity.iconUrl = updates.iconUrl;
    }
    if (updates.model) {
      await this.checkModel(updates.model, teamId);
      entity.model = updates.model;
    }
    if (updates.customModelName != undefined) {
      if (updates.customModelName !== entity.customModelName) {
        await this.checkCustomModelUnique(teamId, updates.customModelName);
      }
      entity.customModelName = updates.customModelName;
    }
    if (updates.systemPrompt != undefined) {
      entity.systemPrompt = updates.systemPrompt;
    }
    if (updates.knowledgeBase) {
      entity.knowledgeBase = updates.knowledgeBase;
    }
    if (updates.sqlKnowledgeBase) {
      entity.sqlKnowledgeBase = updates.sqlKnowledgeBase;
    }
    if (updates.tools) {
      entity.tools = updates.tools;
    }
    if (updates.temperature != undefined) {
      entity.temperature = updates.temperature;
    }
    if (updates.presence_penalty != undefined) {
      entity.presence_penalty = updates.presence_penalty;
    }
    if (updates.frequency_penalty != undefined) {
      entity.frequency_penalty = updates.frequency_penalty;
    }
    entity.updatedTimestamp = Date.now();
    return await this.repository.save(entity);
  }

  private getDateList(startTimestamp: number, endTimestamp: number) {
    const startDate = new Date(startTimestamp);
    const endDate = new Date(endTimestamp);
    endDate.setDate(endDate.getDate() + 1);

    const dateList = [];
    const currentDate = startDate;

    while (currentDate <= endDate) {
      const year = currentDate.getFullYear();
      const month = String(currentDate.getMonth() + 1).padStart(2, '0');
      const day = String(currentDate.getDate()).padStart(2, '0');

      dateList.push(`${year}-${month}-${day}`);

      // Move to the next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return dateList;
  }

  public async createConversationExecution(userId: string, appId: string, status: ConversationStatusEnum, takes: number) {
    await this.executionRepository.save({
      id: generateDbId(),
      createdTimestamp: +Date.now(),
      updatedTimestamp: +Date.now(),
      isDeleted: false,
      userId,
      status,
      takes,
      appId,
    });
  }

  public async getExecutionStatisticsByAppId(conversationAppId: string, startTimestamp: number, endTimestamp: number) {
    const appId = config.server.appId;
    const callsPerDateSql = `
SELECT
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_conversation_executions
WHERE app_id = '${conversationAppId}' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    app_id,
    date;
    `;

    const successPerDateSql = `
SELECT
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_conversation_executions
WHERE app_id = '${conversationAppId}' AND status = 'SUCCEED' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    app_id,
    date;
`;

    const failedPerDateSql = `
SELECT
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_conversation_executions
WHERE app_id = '${conversationAppId}' AND status = 'FAILED' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    app_id,
    date;
`;

    const averageTakesPerDateSql = `
SELECT
  app_id,
  TO_CHAR(TO_TIMESTAMP(created_timestamp / 1000), 'YYYY-MM-DD') AS date,
  AVG(takes) AS average_time
FROM
  ${appId}_conversation_executions
WHERE
  status = 'SUCCEED' AND app_id = '${conversationAppId}' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
  app_id,
  date
ORDER BY
  app_id,
  date;
    `;

    const dateList = this.getDateList(startTimestamp, endTimestamp);
    const [callsPerDayResult, successPerDayResult, failedPerDayResult, averageTakesPerDayResult] = await Promise.all([
      this.executionRepository.query(callsPerDateSql),
      this.executionRepository.query(successPerDateSql),
      this.executionRepository.query(failedPerDateSql),
      this.executionRepository.query(averageTakesPerDateSql),
    ]);

    const result: Array<{
      date: string;
      totalCount: number;
      successCount: number;
      failedCount: number;
      averageTime: number;
    }> = [];
    for (const date of dateList) {
      const callsPerDay = callsPerDayResult.find((x) => x.date === date);
      const successPerDay = successPerDayResult.find((x) => x.date === date);
      const failedPerDay = failedPerDayResult.find((x) => x.date === date);
      const averageTakesPerDay = averageTakesPerDayResult.find((x) => x.date === date);
      result.push({
        date,
        totalCount: parseInt(callsPerDay?.total_calls) || 0,
        successCount: parseInt(successPerDay?.total_calls) || 0,
        failedCount: parseInt(failedPerDay?.total_calls) || 0,
        averageTime: parseInt(averageTakesPerDay?.average_time) || 0,
      });
    }
    return result;
  }

  public async getExecutionStatisticsByTeamId(teamId: string, startTimestamp: number, endTimestamp: number) {
    const dateList = this.getDateList(startTimestamp, endTimestamp);

    const appId = config.server.appId;
    const appIds = _.uniq(
      (
        await this.repository.find({
          where: {
            teamId,
          },
          select: ['id'],
        })
      ).map((x) => x.id),
    );

    if (appIds.length === 0) {
      return dateList.map((date) => {
        return {
          date,
          totalCount: 0,
          successCount: 0,
          failedCount: 0,
          averageTime: 0,
        };
      });
    }

    const appIdsStr = appIds.map((x) => `'${x}'`).join(',');
    const callsPerDateSql = `
SELECT
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_conversation_executions
WHERE app_id IN (${appIdsStr}) AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    app_id,
    date;
    `;

    const successPerDateSql = `
SELECT
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_conversation_executions
WHERE app_id IN (${appIdsStr}) AND status = 'SUCCEED' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    app_id,
    date;
`;

    const failedPerDateSql = `
SELECT
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_conversation_executions
WHERE app_id IN (${appIdsStr}) AND status = 'FAILED' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    app_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    app_id,
    date;
`;

    const averageTakesPerDateSql = `
SELECT
  app_id,
  TO_CHAR(TO_TIMESTAMP(created_timestamp / 1000), 'YYYY-MM-DD') AS date,
  AVG(takes) AS average_time
FROM
  ${appId}_conversation_executions
WHERE
  status = 'SUCCEED' AND app_id IN (${appIdsStr}) AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
  app_id,
  date
ORDER BY
  app_id,
  date;
    `;

    const [callsPerDayResult, successPerDayResult, failedPerDayResult, averageTakesPerDayResult] = await Promise.all([
      this.executionRepository.query(callsPerDateSql),
      this.executionRepository.query(successPerDateSql),
      this.executionRepository.query(failedPerDateSql),
      this.executionRepository.query(averageTakesPerDateSql),
    ]);

    const result: Array<{
      date: string;
      totalCount: number;
      successCount: number;
      failedCount: number;
      averageTime: number;
    }> = [];
    for (const date of dateList) {
      const callsPerDay = callsPerDayResult.find((x) => x.date === date);
      const successPerDay = successPerDayResult.find((x) => x.date === date);
      const failedPerDay = failedPerDayResult.find((x) => x.date === date);
      const averageTakesPerDay = averageTakesPerDayResult.find((x) => x.date === date);
      result.push({
        date,
        totalCount: parseInt(callsPerDay?.total_calls) || 0,
        successCount: parseInt(successPerDay?.total_calls) || 0,
        failedCount: parseInt(failedPerDay?.total_calls) || 0,
        averageTime: parseInt(averageTakesPerDay?.average_time) || 0,
      });
    }
    return result;
  }
}

================================================================================

repositories/credential.repository.ts:
--------------------------------------------------------------------------------
import { CredentialDefinition } from '@/common/typings/tools';
import { generateDbId } from '@/common/utils';
import { ToolsCredentialTypeEntity } from '@/database/entities/tools/tools-credential-type.entity';
import { ToolsCredentialEntity } from '@/database/entities/tools/tools-credential.entity';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DeepPartial, FindManyOptions, In, Repository } from 'typeorm';

@Injectable()
export class CredentialsRepository {
  constructor(
    @InjectRepository(ToolsCredentialTypeEntity)
    private readonly toolsCredentialTypeRepository: Repository<ToolsCredentialTypeEntity>,
    @InjectRepository(ToolsCredentialEntity)
    private readonly toolsCredentialRepository: Repository<ToolsCredentialEntity>,
  ) {}

  public async createOrUpdateCredentialTypes(namespace: string, latestCredentials: CredentialDefinition[]) {
    latestCredentials = latestCredentials.map((x) => {
      x.name = `${namespace}:${x.name}`;
      return x;
    });
    const latestCredentialNames = latestCredentials.map((x) => x.name);
    const originalCredentials = await this.toolsCredentialTypeRepository.find({
      where: {
        namespace,
        isDeleted: false,
      },
    });
    const originalCredentialNames = originalCredentials.map((x) => x.name);
    const credentialsToDelete = originalCredentials.filter((x) => !latestCredentialNames.includes(x.name));
    const credentialsToCreate = latestCredentials.filter((x) => !originalCredentialNames.includes(x.name));
    const credentialsToUpdate = originalCredentials.filter((x) => latestCredentialNames.includes(x.name));

    if (credentialsToCreate.length) {
      const entitiesToCreate: ToolsCredentialTypeEntity[] = credentialsToCreate.map(
        (x): ToolsCredentialTypeEntity => ({
          id: generateDbId(),
          isDeleted: false,
          createdTimestamp: +new Date(),
          updatedTimestamp: +new Date(),
          type: x.type,
          namespace: namespace,
          name: x.name,
          displayName: x.displayName,
          description: x.description,
          iconUrl: x.iconUrl,
          properties: x.properties,
        }),
      );
      await this.toolsCredentialTypeRepository.save(entitiesToCreate);
    }

    if (credentialsToDelete.length) {
      await this.toolsCredentialTypeRepository.update(
        {
          namespace,
          name: In(credentialsToDelete.map((x) => x.name)),
        },
        {
          isDeleted: true,
        },
      );
    }

    if (credentialsToUpdate.length) {
      const entitiesToUpdate = credentialsToUpdate.map((x): ToolsCredentialTypeEntity => {
        const latestDef = latestCredentials.find((t) => x.name === t.name);
        return {
          ...x,
          id: x.id,
          updatedTimestamp: +new Date(),
          displayName: latestDef.displayName,
          description: latestDef.description,
          iconUrl: latestDef.iconUrl,
          properties: latestDef.properties,
          type: latestDef.type,
        };
      });
      await this.toolsCredentialTypeRepository.save(entitiesToUpdate);
    }
  }

  public async getCredentialTypes() {
    return await this.toolsCredentialTypeRepository.find({
      where: {
        isDeleted: false,
      },
    });
  }

  public async getCredentialType(name: string) {
    return this.toolsCredentialTypeRepository.findOne({
      where: {
        name,
      },
    });
  }

  public async listCredentials(teamId: string, credentialType?: string) {
    const condition: FindManyOptions<ToolsCredentialEntity> = {
      where: {
        teamId,
        isDeleted: false,
        type: credentialType,
      },
    };
    const list = await this.toolsCredentialRepository.find(condition);
    return list;
  }

  public async getCredentialById(teamId: string, credentialId: string) {
    const entity = await this.toolsCredentialRepository.findOne({
      where: {
        teamId,
        id: credentialId,
        isDeleted: false,
      },
    });
    return entity;
  }

  public async isCredentialBelongToTeam(teamId: string, credentialId: string) {
    const entity = await this.toolsCredentialRepository.findOne({
      where: {
        teamId,
        id: credentialId,
      },
    });
    return !!entity;
  }

  public async deleteCredential(teamId: string, id: string) {
    const credential = await this.toolsCredentialRepository.findOne({
      where: {
        id,
        teamId,
        isDeleted: false,
      },
    });
    if (!credential) {
      throw new Error(`密钥 ${id} 不存在`);
    }
    await this.toolsCredentialRepository.update(
      {
        id,
        teamId,
      },
      {
        isDeleted: true,
      },
    );
    return {
      success: true,
    };
  }

  public async createCredentail(data: Partial<ToolsCredentialEntity>) {
    await this.toolsCredentialRepository.save(data);
  }

  public async updateCredential(teamId: string, id: string, displayName: string, encryptedData: string) {
    const credential = await this.toolsCredentialRepository.findOne({
      where: {
        id,
        teamId,
        isDeleted: false,
      },
    });
    if (!credential) {
      throw new Error(`Credential ${id} not exists`);
    }
    const updates: DeepPartial<ToolsCredentialEntity> = {
      updatedTimestamp: +new Date(),
    };
    if (displayName) {
      updates.displayName = displayName;
    }
    if (encryptedData) {
      updates.encryptedData = encryptedData;
    }
    await this.toolsCredentialRepository.update(
      {
        id: id,
        teamId,
        isDeleted: false,
      },
      updates,
    );
    return await this.getCredentialById(teamId, id);
  }
}

================================================================================

repositories/knowledge-base-sql.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { generateDbId } from '@/common/utils';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CreateSqlKnowledgeBaseParams, SqlKnowLedgeBaseEntity } from '../entities/assets/knowledge-base/knowledge-base-sql.entity';
import { SqlKnowledgeBaseAssetRepositroy } from './assets-knowledge-base-sql.repository';

@Injectable()
export class SqlKnowledgeBaseRepository {
  constructor(
    @InjectRepository(SqlKnowLedgeBaseEntity)
    private readonly sqlKnowledgeBaseRepository: Repository<SqlKnowLedgeBaseEntity>,
    private readonly sqlKnowledgeBaseAssetRepositroy: SqlKnowledgeBaseAssetRepositroy,
  ) {}

  public async listSqlKnowledgeBases(teamId: string, dto: ListDto) {
    return await this.sqlKnowledgeBaseAssetRepositroy.listAssets('sql-knowledge-base', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }

  public async createSqlKnowledgeBase(teamId: string, userId: string, uuid: string, params: CreateSqlKnowledgeBaseParams) {
    const sqlKnowledgeBase = new SqlKnowLedgeBaseEntity();
    sqlKnowledgeBase.id = generateDbId();
    sqlKnowledgeBase.uuid = uuid;
    sqlKnowledgeBase.displayName = params.displayName || params.externalDatabaseConnectionOptions?.database || 'Unknown';
    sqlKnowledgeBase.description = params.description || '';
    sqlKnowledgeBase.iconUrl = params.iconUrl || 'emoji:🍀:#ceefc5';
    sqlKnowledgeBase.teamId = teamId;
    sqlKnowledgeBase.creatorUserId = userId;
    sqlKnowledgeBase.createdTimestamp = +new Date();
    sqlKnowledgeBase.updatedTimestamp = +new Date();
    sqlKnowledgeBase.isDeleted = false;
    sqlKnowledgeBase.createType = params.createType;
    return await this.sqlKnowledgeBaseRepository.save(sqlKnowledgeBase);
  }

  public async getSqlKnowledgeBaseByUUID(teamId: string, uuid: string) {
    return await this.sqlKnowledgeBaseRepository.findOne({
      where: {
        uuid,
        teamId,
        isDeleted: false,
      },
    });
  }

  public async deleteSqlKnowledgeBase(teamId: string, uuid: string) {
    const knowledgeBase = await this.getSqlKnowledgeBaseByUUID(teamId, uuid);
    if (!knowledgeBase) {
      return;
    }
    knowledgeBase.isDeleted = true;
    knowledgeBase.updatedTimestamp = Date.now();
    await this.sqlKnowledgeBaseRepository.save(knowledgeBase);
  }
}

================================================================================

repositories/knowledge-base.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { generateDbId } from '@/common/utils';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { KnowLedgeBaseEntity, KnowledgeBaseRetrievalSettings } from '../entities/assets/knowledge-base/knowledge-base.entity';
import { KnowledgeBaseAssetRepositroy } from './assets-knowledge-base.repository';

export interface CreateKnowledgeBaseParams {
  uuid: string;
  displayName: string;
  description: string;
  embeddingModel: string;
  iconUrl: string;
  dimension: number;
}

@Injectable()
export class KnowledgeBaseRepository {
  constructor(
    @InjectRepository(KnowLedgeBaseEntity)
    private readonly knowledgeBaseRepository: Repository<KnowLedgeBaseEntity>,
    private readonly knowledgeBaseAssetRepositroy: KnowledgeBaseAssetRepositroy,
  ) {}

  public async listKnowledgeBases(teamId: string, dto: ListDto) {
    return await this.knowledgeBaseAssetRepositroy.listAssets('knowledge-base', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }

  public async createKnowledgeBase(teamId: string, creatorUserId: string, params: CreateKnowledgeBaseParams) {
    const knowledgeBase = new KnowLedgeBaseEntity();
    knowledgeBase.id = generateDbId();
    knowledgeBase.teamId = teamId;
    knowledgeBase.uuid = params.uuid;
    knowledgeBase.dimension = params.dimension;
    knowledgeBase.creatorUserId = creatorUserId;
    knowledgeBase.displayName = params.displayName;
    knowledgeBase.description = params.description;
    knowledgeBase.embeddingModel = params.embeddingModel;
    knowledgeBase.iconUrl = params.iconUrl;
    knowledgeBase.createdTimestamp = Date.now();
    knowledgeBase.updatedTimestamp = Date.now();
    const result = await this.knowledgeBaseRepository.save(knowledgeBase);
    return result;
  }

  public async getKnowledgeBaseByUUIDWithoutTeam(knowledgeBaseId: string) {
    const knowledgeBase = await this.knowledgeBaseRepository.findOne({
      where: {
        uuid: knowledgeBaseId,
        isDeleted: false,
      },
    });
    if (!knowledgeBase) {
      throw new Error('Knowledge base not found');
    }
    return knowledgeBase;
  }

  public async getKnowledgeBaseByUUID(teamId: string, knowledgeBaseId: string) {
    const knowledgeBase = await this.knowledgeBaseRepository.findOne({
      where: {
        uuid: knowledgeBaseId,
        teamId,
        isDeleted: false,
      },
    });
    if (!knowledgeBase) {
      throw new Error('Knowledge base not found');
    }
    return knowledgeBase;
  }

  public async updateKnowledgeBase(
    teamId: string,
    knowledgeBaseId: string,
    updates: {
      displayName?: string;
      description?: string;
      iconUrl?: string;
      retrievalSettings?: KnowledgeBaseRetrievalSettings;
    },
  ) {
    const knowledgeBase = await this.getKnowledgeBaseByUUID(teamId, knowledgeBaseId);
    if (!knowledgeBase) {
      return null;
    }
    if (updates.displayName) {
      knowledgeBase.displayName = updates.displayName;
    }
    if (updates.description) {
      knowledgeBase.description = updates.description;
    }
    if (updates.iconUrl) {
      knowledgeBase.iconUrl = updates.iconUrl;
    }
    if (updates.retrievalSettings) {
      knowledgeBase.retrievalSettings = updates.retrievalSettings;
    }
    knowledgeBase.updatedTimestamp = Date.now();
    return await this.knowledgeBaseRepository.save(knowledgeBase);
  }

  public async deleteKnowledgeBase(teamId: string, knowledgeBaseId: string) {
    const knowledgeBase = await this.getKnowledgeBaseByUUID(teamId, knowledgeBaseId);
    if (!knowledgeBase) {
      return;
    }
    knowledgeBase.isDeleted = true;
    knowledgeBase.updatedTimestamp = Date.now();
    await this.knowledgeBaseRepository.save(knowledgeBase);
  }
}

================================================================================

repositories/llm-model.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { ONEAPI_CHANNELS } from '@/common/oneapi/consts';
import { generateDbId } from '@/common/utils';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { LlmModelEntity, LlmOneapiModel, UpdateLlmModelParams } from '../entities/assets/model/llm-model/llm-model';
import { LlmModelAssetRepositroy } from './assets-llm-model.respository';

@Injectable()
export class LlmModelRepository {
  constructor(
    private readonly llmModelAssetRepositroy: LlmModelAssetRepositroy,
    @InjectRepository(LlmModelEntity) private readonly llmModelRepository: Repository<LlmModelEntity>,
  ) {}

  public async deleteLLMModel(teamId: string, id: string) {
    await this.llmModelRepository.update(
      {
        teamId,
        isDeleted: false,
        id,
      },
      {
        isDeleted: true,
        updatedTimestamp: +new Date(),
      },
    );
  }

  public async getLLMModel(teamId: string, id: string) {
    return await this.llmModelRepository.findOne({
      where: {
        teamId,
        id,
        isDeleted: false,
      },
    });
  }

  public async listLlmModels(teamId: string, dto: ListDto) {
    return await this.llmModelAssetRepositroy.listAssets('llm-model', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }

  public async createLLMModel(teamId: string, creatorUserId: string, channelType: number, channelId: number, models: LlmOneapiModel, icon?: string, displayName?: string, description?: string) {
    const oneapiChannel = ONEAPI_CHANNELS.find((channel) => channel.id === channelType.toString());

    if (!oneapiChannel) {
      throw new Error('Invalid LLM Model type');
    }

    const finalDisplayName = displayName?.toString() || oneapiChannel.displayName;
    const finalDescription = description ? `${description?.toString()} | ` : '';

    const entity: Partial<LlmModelEntity> = {
      id: generateDbId(),
      teamId,
      creatorUserId,
      isDeleted: false,
      createdTimestamp: +new Date(),
      updatedTimestamp: +new Date(),
      iconUrl: icon || oneapiChannel.iconUrl,
      displayName: finalDisplayName,
      description: {
        'zh-CN': `${finalDescription}由 ${typeof finalDisplayName === 'object' ? Object.values(finalDisplayName)[0] : finalDisplayName} 提供，支持 ${Object.values(models).join(', ')} 模型`,
        'en-US': `${finalDescription}Provided by ${finalDisplayName}, support ${Object.values(models).join(', ')} models`,
      },
      channelType,
      channelId,
      models,
    };
    await this.llmModelRepository.save(entity);
    return entity;
  }

  public async getLLMModelByChannelType(teamId: string, channelType: number) {
    return await this.llmModelRepository.findOne({
      where: {
        teamId,
        channelType,
        isDeleted: false,
      },
    });
  }

  public async getLLMModelByChannelId(channelId: number) {
    return await this.llmModelRepository.findOne({
      where: {
        channelId,
        isDeleted: false,
      },
    });
  }

  public async updateLLMModel(id: string, dto: UpdateLlmModelParams) {
    return await this.llmModelRepository.update(id, {
      ...dto,
      updatedTimestamp: +new Date(),
    });
  }
}

================================================================================

repositories/media.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { S3Helpers } from '@/common/s3';
import { generateDbId } from '@/common/utils';
import { MediaSource } from '@/database/entities/assets/media/media-file';
import { CreateRichMediaDto } from '@/modules/assets/media/dto/req/create-rich-media.dto';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { MediaFileEntity } from '../entities/assets/media/media-file';
import { MediaFileAssetRepositroy } from './assets-media-file.repository';

@Injectable()
export class MediaFileRepository {
  constructor(
    @InjectRepository(MediaFileEntity)
    private readonly mediaFileRepository: Repository<MediaFileEntity>,
    private readonly mediaFileAssetRepositroy: MediaFileAssetRepositroy,
  ) {}

  private async refreshLogo(records: MediaFileEntity[]) {
    const promises = records.filter(Boolean).map(async (record) => {
      if (record.iconUrl) {
        try {
          const s3Helpers = new S3Helpers();
          const { refreshed, refreshedUrl } = await s3Helpers.refreshSignedUrl(record.iconUrl);
          if (refreshed) {
            record.iconUrl = refreshedUrl;
            await this.mediaFileRepository.save(record);
          }
        } catch (e) {}
      }
    });
    await Promise.all(promises);
  }

  public async listRichMedias(teamId: string, dto: ListDto) {
    const { list, totalCount } = await this.mediaFileAssetRepositroy.listAssets('media-file', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
    await this.refreshLogo(list);
    return {
      list,
      totalCount,
    };
  }

  public async deleteMedia(teamId: string, id: string) {
    const data = await this.mediaFileRepository.findOne({
      where: {
        id,
        teamId,
      },
    });
    if (!data) {
      return;
    }
    await this.mediaFileRepository.update(
      {
        id,
        teamId,
      },
      {
        isDeleted: true,
      },
    );
  }

  public async getMediaById(id: string) {
    const data = await this.mediaFileRepository.findOne({
      where: {
        id: id,
      },
    });
    await this.refreshLogo([data]);
    return data;
  }

  public async getMediaByMd5(teamId: string, md5: string) {
    const data = await this.mediaFileRepository.findOne({
      where: {
        md5,
        teamId,
        isDeleted: false,
      },
    });
    await this.refreshLogo([data]);
    return data;
  }

  public async createMedia(teamId: string, userId: string, body: CreateRichMediaDto) {
    const { url, source = MediaSource.UPLOAD, displayName, params, type, size, md5 } = body;
    const mediaId = generateDbId();
    await this.mediaFileRepository.save({
      id: mediaId,
      iconUrl: '',
      description: '',
      type,
      teamId,
      creatorUserId: userId,
      displayName,
      url,
      source: source as any,
      params,
      size,
      md5,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      isDeleted: false,
    });
    return await this.getMediaById(mediaId);
  }
}

================================================================================

repositories/observability.repository.ts:
--------------------------------------------------------------------------------
import { generateDbId } from '@/common/utils';
import { ObservabilityPlatform, ObservabilityPlatformConfig } from '@/modules/workflow/interfaces/observability';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { WorkflowObservabilityEntity } from '../entities/observability/workflow-observability';

@Injectable()
export class ObservabilityRepository {
  constructor(
    @InjectRepository(WorkflowObservabilityEntity)
    private readonly workflowObservabilityRepository: Repository<WorkflowObservabilityEntity>,
  ) { }

  public async createWorkflowObservability(teamId: string, workflowId: string, platform: ObservabilityPlatform, platformConfig: ObservabilityPlatformConfig, name?: string) {
    const entity: Partial<WorkflowObservabilityEntity> = {
      id: generateDbId(),
      isDeleted: false,
      createdTimestamp: +new Date(),
      updatedTimestamp: +new Date(),
      teamId,
      workflowId,
      platform,
      platformConfig,
      name,
    };
    await this.workflowObservabilityRepository.save(entity);
    return entity;
  }

  public async getWorkflowObservability(teamId: string, workflowId: string) {
    return this.workflowObservabilityRepository.find({
      where: {
        teamId,
        workflowId,
      },
    });
  }

  public async deleteWorkflowObservability(observabilityId: string) {
    await this.workflowObservabilityRepository.delete({
      id: observabilityId,
    });
  }
}

================================================================================

repositories/oneapi.respository.ts:
--------------------------------------------------------------------------------
import { generateDbId } from '@/common/utils';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { OneApiUsersEntity } from '../entities/oneapi/oneapi-user.entity';

@Injectable()
export class OneApiRepository {
  constructor(
    @InjectRepository(OneApiUsersEntity)
    private readonly oneApiUserEntity: Repository<OneApiUsersEntity>,
  ) {}

  public async getOneapiUserByTeamId(teamId: string) {
    return this.oneApiUserEntity.findOne({
      where: {
        teamId,
        isDeleted: false,
      },
    });
  }

  public async createOneapiUser(teamId: string, userId: number, userToken: string, apiKey: string, username: string, password: string) {
    const entity: Partial<OneApiUsersEntity> = {
      id: generateDbId(),
      isDeleted: false,
      createdTimestamp: +new Date(),
      updatedTimestamp: +new Date(),
      teamId,
      userId,
      apiKey,
      userToken,
      username,
      password,
    };
    await this.oneApiUserEntity.save(entity);
    return entity;
  }
}

================================================================================

repositories/sd-model.repository.ts:
--------------------------------------------------------------------------------
import { ListDto } from '@/common/dto/list.dto';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SdModelEntity } from '../entities/assets/model/sd-model/sd-model';
import { SdModelAssetRepositroy } from './assets-sd-model.repository';

@Injectable()
export class SdModelRepository {
  constructor(
    @InjectRepository(SdModelEntity)
    private readonly llmModelRepository: Repository<SdModelEntity>,
    private readonly sdModelAssetRepositroy: SdModelAssetRepositroy,
  ) {}

  public async listSdModels(teamId: string, dto: ListDto) {
    return await this.sdModelAssetRepositroy.listAssets('sd-model', teamId, dto, {
      withTags: true,
      withTeam: true,
      withUser: true,
    });
  }
}

================================================================================

repositories/system-configuration.repository.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { logger } from '@/common/logger';
import { generateOneApiTokenByUsernamePassword } from '@/common/oneapi';
import { generateDbId, maskString } from '@/common/utils';
import { SystemConfigurationEntity } from '@/database/entities/system/system-configuration.entity';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import crypto from 'crypto';
import { Repository } from 'typeorm';

@Injectable()
export class SystemConfigurationRepository {
  private THEME_CONFIG_KEY = 'theme';
  private AES_ENCRYPT_KEY = 'aesEncryptKey';
  private ONEAPI_ROOT_USER_TOKEN_KEY = 'oneapiRootUserToken';

  constructor(
    @InjectRepository(SystemConfigurationEntity)
    private readonly systemConfigurationEntity: Repository<SystemConfigurationEntity>,
  ) {}

  public async getAesKey() {
    const configuration = await this.systemConfigurationEntity.findOne({
      where: {
        key: this.AES_ENCRYPT_KEY,
      },
    });
    if (!configuration) {
      throw new Error('UNEXPECTED ERROR: aesEncryptKey not found, maybe system not configured properly.');
    }
    return configuration.value;
  }

  public async initAesKey() {
    if (await this.systemConfigurationEntity.exists({ where: { key: this.AES_ENCRYPT_KEY } })) {
      return;
    }
    const entity: SystemConfigurationEntity = {
      id: generateDbId(),
      createdTimestamp: +new Date(),
      updatedTimestamp: +new Date(),
      isDeleted: false,
      key: this.AES_ENCRYPT_KEY,
      value: crypto.randomBytes(32).toString('hex'),
    };
    await this.systemConfigurationEntity.save(entity);
  }

  public async getThemeConfig() {
    const configuration = await this.systemConfigurationEntity.findOne({
      where: {
        key: this.THEME_CONFIG_KEY,
      },
    });
    if (!configuration) {
      return null;
    }
    return JSON.parse(configuration.value);
  }

  public async getOneApiRootUserToken() {
    const configuration = await this.systemConfigurationEntity.findOne({
      where: {
        key: this.ONEAPI_ROOT_USER_TOKEN_KEY,
      },
    });
    if (!configuration) {
      throw new Error('UNEXPECTED ERROR: oneapiRootUserToken not found, maybe system not configured properly.');
    }
    return configuration.value;
  }

  public async initOneApiRootUserToken() {
    if (!config.oneapi.enabled) {
      return;
    }

    // If set rootToken in config, allways update it to db
    if (config.oneapi.rootToken) {
      const token = config.oneapi.rootToken;
      const configuration = await this.systemConfigurationEntity.findOne({
        where: {
          key: this.ONEAPI_ROOT_USER_TOKEN_KEY,
        },
      });
      if (configuration) {
        configuration.value = token;
        await this.systemConfigurationEntity.save(configuration);
      } else {
        const entity: SystemConfigurationEntity = {
          id: generateDbId(),
          createdTimestamp: +new Date(),
          updatedTimestamp: +new Date(),
          isDeleted: false,
          key: this.ONEAPI_ROOT_USER_TOKEN_KEY,
          value: token,
        };
        await this.systemConfigurationEntity.save(entity);
      }
    } else {
      // Else, auto generate token first time and save to db
      const configuration = await this.systemConfigurationEntity.findOne({
        where: {
          key: this.ONEAPI_ROOT_USER_TOKEN_KEY,
        },
      });
      if (configuration) {
        return;
      }
      const { rootUsername, rootPassword } = config.oneapi;
      logger.info(`Auto generate oneapi root user token, username=${rootUsername}, password=${maskString(rootPassword)}`);
      const token = await generateOneApiTokenByUsernamePassword(config.oneapi.baseURL, rootUsername, rootPassword);
      const entity: SystemConfigurationEntity = {
        id: generateDbId(),
        createdTimestamp: +new Date(),
        updatedTimestamp: +new Date(),
        isDeleted: false,
        key: this.ONEAPI_ROOT_USER_TOKEN_KEY,
        value: token,
      };
      await this.systemConfigurationEntity.save(entity);
    }
  }
}

================================================================================

repositories/team.repository.ts:
--------------------------------------------------------------------------------
import { S3Helpers } from '@/common/s3';
import { generateDbId, isValidObjectId } from '@/common/utils';
import { getMap } from '@/common/utils/map';
import { CustomTheme, TeamEntity } from '@/database/entities/identity/team';
import { TeamInviteLinkOutdateType, TeamInviteStatus, TeamInviteType, TeamInvitesRequestsEntity } from '@/database/entities/identity/team-invites';
import { TeamMembersEntity } from '@/database/entities/identity/user-team-relationship';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import dayjs from 'dayjs';
import _, { uniq } from 'lodash';
import { In, Repository } from 'typeorm';
import { TeamJoinRequestStatus, TeamJoinRequestsEntity } from '../entities/identity/team-join-request';
import { UserEntity } from '../entities/identity/user';
import { ApikeyRepository } from './apikey.repository';
import { UserRepository } from './user.repository';

@Injectable()
export class TeamRepository {
  constructor(
    @InjectRepository(TeamEntity)
    private readonly teamRepository: Repository<TeamEntity>,
    @InjectRepository(TeamMembersEntity)
    private readonly teamMembersRepository: Repository<TeamMembersEntity>,
    @InjectRepository(TeamJoinRequestsEntity)
    private readonly teamJoinRequestRepository: Repository<TeamJoinRequestsEntity>,
    @InjectRepository(TeamInvitesRequestsEntity)
    private readonly teamInvitesRequestsRepository: Repository<TeamInvitesRequestsEntity>,
    private readonly apiKeyRepository: ApikeyRepository,
    private readonly userRepository: UserRepository,
  ) {}

  private async refreshLogo(teams: TeamEntity[]) {
    const promises = teams.filter(Boolean).map(async (team) => {
      if (team.iconUrl) {
        try {
          const s3Helpers = new S3Helpers();
          const { refreshed, refreshedUrl } = await s3Helpers.refreshSignedUrl(team.iconUrl);
          if (refreshed) {
            team.iconUrl = refreshedUrl;
            await this.teamRepository.save(team);
          }
        } catch (e) {}
      }
      if (team.darkmodeIconUrl) {
        try {
          const s3Helpers = new S3Helpers();
          const { refreshed, refreshedUrl } = await s3Helpers.refreshSignedUrl(team.darkmodeIconUrl);
          if (refreshed) {
            team.darkmodeIconUrl = refreshedUrl;
            await this.teamRepository.save(team);
          }
        } catch (e) {}
      }
    });
    await Promise.all(promises);
  }

  public async getTeamById(id: string) {
    const team = await this.teamRepository.findOne({
      where: {
        id,
      },
    });
    await this.refreshLogo([team]);
    return team;
  }

  public async getTeamsByIds(ids: string[]) {
    const teams = await this.teamRepository.find({
      where: {
        id: In(ids),
        isDeleted: false,
      },
    });
    await this.refreshLogo(teams);
    return teams;
  }

  public async getTeamsByIdsAsMap(ids: string[]) {
    let teamHash: Record<string, TeamEntity> = {};
    if (ids?.length) {
      const teams = await this.getTeamsByIds(ids);
      teamHash = getMap(teams, (u) => u.id);
    }
    return teamHash;
  }

  async getUserTeams(userId: string): Promise<TeamEntity[]> {
    const relationships = await this.teamMembersRepository.find({
      where: {
        userId,
        isDeleted: false,
      },
    });
    const teamIds = Array.from(new Set(relationships.map((r) => r.teamId)));
    if (!teamIds.length) {
      return [];
    }
    const teams = await this.teamRepository.find({
      where: {
        id: In(teamIds),
        isDeleted: false,
      },
    });
    await this.refreshLogo(teams);
    return teams;
  }

  public async checkNameConflict(userId: string, name: string) {
    const team = await this.teamRepository.findOne({
      where: {
        ownerUserId: userId,
        isDeleted: false,
        name: name,
      },
    });
    return !!team;
  }

  public async checkInitialTeamIdConflict(initialTeamId: string) {
    const team = await this.teamRepository.findOne({
      where: {
        id: initialTeamId,
      },
    });
    return !!team;
  }

  async createTeam(userId: string, teamName: string, description?: string, iconUrl?: string, isBuiltIn = false, workflowTaskNamePrefix?: string, initialTeamId?: string, darkmodeIconUrl?: string) {
    if (await this.checkNameConflict(userId, teamName)) {
      throw new Error('同名团队已经存在，请更换名称');
    }
    if (initialTeamId) {
      if (await this.checkInitialTeamIdConflict(initialTeamId)) {
        throw new Error('该团队 ID 已存在');
      }
      if (!isValidObjectId(initialTeamId)) {
        throw new Error('团队 ID 格式不正确');
      }
    }
    const now = Date.now();
    const newTeam: TeamEntity = {
      id: initialTeamId || generateDbId(),
      name: teamName,
      description,
      iconUrl,
      darkmodeIconUrl,
      isBuiltIn,
      createdTimestamp: now,
      updatedTimestamp: now,
      ownerUserId: userId,
      isDeleted: false,
      workflowTaskNamePrefix,
    };
    const teamId = newTeam.id as string;
    const newReplationships: TeamMembersEntity = {
      id: generateDbId(),
      userId,
      teamId,
      createdTimestamp: now,
      updatedTimestamp: now,
      isDeleted: false,
    };
    await this.teamMembersRepository.save(newReplationships);
    await this.teamRepository.save(newTeam);
    await this.apiKeyRepository.initApiKeyIfNotExists(teamId, userId);

    return newTeam;
  }

  public async deleteTeam(teamId: string) {
    const res = await this.teamRepository.update(
      {
        id: teamId,
      },
      {
        isDeleted: true,
      },
    );
    return !!res.affected;
  }

  public async updateTeam(
    teamId: string,
    updates?: {
      name?: string;
      description?: string;
      iconUrl?: string;
      darkmodeIconUrl?: string;
      customTheme?: CustomTheme;
      oneAPIToken?: string;
      oneAPIPassword?: string;
      oneAPIUsername?: string;
    },
  ) {
    if (!updates || !Object.keys(updates).length) {
      return;
    }
    const { name, description, iconUrl, customTheme, oneAPIPassword, oneAPIToken, oneAPIUsername, darkmodeIconUrl } = updates || {};
    const team = await this.teamRepository.findOne({
      where: {
        id: teamId,
        isDeleted: false,
      },
    });
    if (!team) {
      throw new Error('团队不存在');
    }
    if (name) {
      const conflict = await this.checkNameConflict(team.ownerUserId, name);
      if (conflict) {
        throw new Error('同名团队已经存在，请更换名称');
      }
    }
    const now = Date.now();
    await this.teamRepository.update(
      {
        id: teamId,
      },
      _.pickBy(
        {
          name,
          description,
          iconUrl,
          darkmodeIconUrl,
          customTheme,
          updatedTimestamp: now,
          oneAPIToken,
          oneAPIPassword,
          oneAPIUsername,
        },
        (v) => !_.isNil(v),
      ),
    );
  }

  public async isUserInTeam(userId: string, teamId: string) {
    const entity = await this.teamMembersRepository.findOne({
      where: {
        userId,
        teamId,
        isDeleted: false,
      },
    });
    return !!entity;
  }

  public async getUserIdByTeamId(teamId: string) {
    const entity = await this.teamRepository.findOne({
      where: {
        id: teamId,
        isDeleted: false,
      },
    });
    return entity?.ownerUserId;
  }

  public async getTeamMembers(teamId: string) {
    const relationships = await this.teamMembersRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });
    const userIds = relationships.map((x) => x.userId);
    if (!userIds.length) {
      return [];
    }
    return await this.userRepository.findByIds(userIds);
  }

  public async removeTeamMember(teamId: string, userId: string) {
    const res = await this.teamMembersRepository.update(
      {
        teamId,
        userId,
      },
      {
        isDeleted: true,
      },
    );
    return !!res.affected;
  }

  public async makeJoinTeamRequest(teamId: string, userId: string) {
    const team = await this.getTeamById(teamId);
    if (!team) {
      throw new Error('团队不存在');
    }

    const isAccepted = await this.isUserInTeam(userId, teamId);
    if (isAccepted) {
      throw new Error('您已加入该团队，无需重复加入：'.concat(teamId));
    }

    if (!team.enableJoinRequest) {
      throw new Error('团队未开放申请加入');
    }

    const hasRequested = await this.teamJoinRequestRepository.exists({
      where: {
        teamId,
        userId,
        status: TeamJoinRequestStatus.PENDING,
      },
    });
    if (hasRequested) {
      throw new Error('您已申请加入该团队，请耐心等待审批');
    }

    const now = Date.now();
    await this.teamJoinRequestRepository.save({
      id: generateDbId(),
      createdTimestamp: now,
      updatedTimestamp: now,
      teamId: teamId,
      userId: userId,
      status: TeamJoinRequestStatus.PENDING,
    });
  }

  public async listJoinRequests(teamId: string) {
    const records = await this.teamJoinRequestRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });

    const userIds = uniq(records.map((x) => x.userId));
    const users = await this.userRepository.findByIds(userIds);

    const result: Array<TeamJoinRequestsEntity & { user: UserEntity }> = records.map((record) => ({
      ...record,
      user: users.find((user) => user.id === record.userId),
    }));
    return result;
  }

  public async createTeamInviteId(teamId: string, inviterUserId: string, outdateType: number, targetUserId?: string) {
    const outdateTimestamp = outdateType === TeamInviteLinkOutdateType.SEVEN_DAYS ? dayjs().add(7, 'd').valueOf() : 0;
    const inviteId = generateDbId();
    await this.teamInvitesRequestsRepository.save({
      id: inviteId,
      teamId,
      inviterUserId,
      targetUserId,
      outdateType,
      outdateTimestamp,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      type: Number(targetUserId ? TeamInviteType.INDIVIDUAL : TeamInviteType.PUBLIC),
      status: Number(TeamInviteStatus.EFFECTIVE),
      acceptedUserIds: [],
    });
    return inviteId;
  }

  public async getTeamInvites(teamId: string) {
    const invites = await this.teamInvitesRequestsRepository.find({
      where: {
        teamId,
      },
    });
    const userIds = uniq(invites.map((x) => x.targetUserId));
    const users = await this.userRepository.findByIds(userIds);
    return invites.map((invite) => ({
      ...invite,
      user: users.find((user) => user.id === invite.targetUserId),
    }));
  }

  public async updateTeamInviteRemark(inviteId: string, remark: string) {
    const res = await this.teamInvitesRequestsRepository.update(
      {
        id: inviteId,
      },
      {
        remark,
      },
    );
    return !!res.affected;
  }

  public async toggleForeverTeamInviteLinkStatus(inviteId: string) {
    const invite = await this.teamInvitesRequestsRepository.findOne({
      where: {
        id: inviteId,
      },
    });
    if (!invite) {
      throw new Error('邀请链接不存在');
    }
    const res = await this.teamInvitesRequestsRepository.update(
      {
        id: inviteId,
      },
      {
        status: Number(invite.status === TeamInviteStatus.DISABLED ? TeamInviteStatus.EFFECTIVE : TeamInviteStatus.DISABLED),
      },
    );

    return !!res.affected;
  }

  public async deleteTeamInvite(inviteId: string) {
    const res = await this.teamInvitesRequestsRepository.delete({
      id: inviteId,
    });
    return !!res.affected;
  }

  public async getTeamInviteById(inviteId: string) {
    const invite = await this.teamInvitesRequestsRepository.findOne({
      where: {
        id: inviteId,
      },
    });
    if (!invite) {
      throw new Error('邀请链接不存在');
    }

    const isForeverInvite = invite?.outdateTimestamp === 0;
    const isIndicateInvite = invite?.outdateTimestamp > Date.now();
    if (!isForeverInvite && !isIndicateInvite) {
      throw new Error('邀请已经过期或无效');
    }

    return invite;
  }

  public async acceptTeamInvite(userId: string, inviteId: string) {
    const invite = await this.getTeamInviteById(inviteId);
    if (invite.status === TeamInviteStatus.DISABLED) {
      throw new Error('邀请链接已被禁用');
    }

    if (invite.type === TeamInviteType.INDIVIDUAL && invite.targetUserId !== userId) {
      throw new Error('邀请链接不适用于当前用户');
    }

    const team = await this.getTeamById(invite.teamId);
    if (!team) {
      throw new Error('团队不存在');
    }

    const isAccepted = await this.isUserInTeam(userId, team.id);
    if (isAccepted) {
      throw new Error('您已加入该团队，无需重复加入：'.concat(team.id));
    }

    const now = Date.now();
    await this.teamMembersRepository.save({
      id: generateDbId(),
      userId,
      teamId: team.id,
      createdTimestamp: now,
      updatedTimestamp: now,
      isDeleted: false,
    });

    invite.acceptedUserIds.push(userId);
    await this.teamInvitesRequestsRepository.update(
      {
        id: inviteId,
      },
      {
        acceptedUserIds: invite.acceptedUserIds,
      },
    );
  }
}

================================================================================

repositories/tools.repository.ts:
--------------------------------------------------------------------------------
import { ManifestJson, RegisterToolOptions } from '@/common/typings/tools';
import { generateDbId } from '@/common/utils';
import { ToolsServerEntity } from '@/database/entities/tools/tools-server.entity';
import { ToolsEntity } from '@/database/entities/tools/tools.entity';
import { ToolDef } from '@inf-monkeys/monkeys';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { In, IsNull, Not, Repository } from 'typeorm';

@Injectable()
export class ToolsRepository {
  constructor(
    @InjectRepository(ToolsEntity)
    private readonly toolsRepository: Repository<ToolsEntity>,
    @InjectRepository(ToolsServerEntity)
    private readonly toolsServerRepository: Repository<ToolsServerEntity>,
  ) {}

  public async isServerNamespaceExists(namespace: string) {
    return await this.toolsServerRepository.exists({
      where: {
        namespace,
        isDeleted: false,
      },
    });
  }

  public async getServerByNamespace(namespace: string) {
    return await this.toolsServerRepository.findOne({
      where: {
        namespace: namespace,
        isDeleted: false,
      },
    });
  }

  public async saveServer(displayName: string, manifestUrl: string, baseUrl: string, data: ManifestJson) {
    // save server info
    const originalEntity = await this.toolsServerRepository.findOne({
      where: {
        namespace: data.namespace,
        isDeleted: false,
      },
    });
    const entity = new ToolsServerEntity();
    entity.id = originalEntity?.id || generateDbId();
    entity.schemaVersion = data.schema_version;
    entity.api = data.api;
    entity.auth = data.auth;
    entity.namespace = data.namespace;
    entity.manifestUrl = manifestUrl;
    entity.baseUrl = baseUrl;
    entity.displayName = displayName;
    entity.triggerEndpoints = data.triggerEndpoints;
    entity.rateLimiter = data.rateLimiter;
    entity.heatlhCheck = data.healthCheck;
    if (data.rsaPublicKey) {
      entity.rasPublicKey = data.rsaPublicKey.trim();
    }
    entity.logEndpoint = data.logEndpoint;
    await this.toolsServerRepository.save(entity);
  }

  public async createOrUpdateTools(namespace: string, latestTools: ToolDef[], options?: RegisterToolOptions) {
    const { isPublic, teamId, userId } = options || {};
    const latestToolNames = latestTools.map((x) => x.name);
    const originalTools = await this.toolsRepository.find({
      where: {
        namespace,
      },
    });
    const originalToolNames = originalTools.map((x) => x.name);
    const toolsToDelete = originalTools.filter((x) => !latestToolNames.includes(x.name));
    const toolsToCreate = latestTools.filter((x) => !originalToolNames.includes(x.name));
    const toolsToUpdate = originalTools.filter((x) => latestToolNames.includes(x.name));

    if (toolsToCreate.length) {
      const entitiesToCreate: ToolsEntity[] = toolsToCreate.map(
        (x): ToolsEntity => ({
          id: generateDbId(),
          isDeleted: false,
          createdTimestamp: +new Date(),
          updatedTimestamp: +new Date(),
          type: x.type,
          namespace: namespace,
          name: x.name,
          displayName: x.displayName,
          description: x.description,
          categories: x.categories,
          credentials: x.credentials,
          icon: x.icon,
          input: x.input,
          output: x.output,
          rules: x.rules,
          extra: x.extra,
          creatorUserId: userId,
          teamId: teamId,
          public: isPublic,
        }),
      );
      await this.toolsRepository.save(entitiesToCreate);
    }

    if (toolsToDelete.length) {
      await this.toolsRepository.update(
        {
          namespace,
          name: In(toolsToDelete.map((x) => x.name)),
        },
        {
          isDeleted: true,
        },
      );
    }

    if (toolsToUpdate.length) {
      const entitiesToUpdate = toolsToUpdate.map((x): ToolsEntity => {
        const latestDef = latestTools.find((t) => x.name === t.name);
        return {
          ...x,
          id: x.id,
          updatedTimestamp: +new Date(),
          displayName: latestDef.displayName,
          description: latestDef.description,
          categories: latestDef.categories,
          credentials: latestDef.credentials,
          icon: latestDef.icon,
          input: latestDef.input,
          output: latestDef.output,
          rules: latestDef.rules,
          extra: latestDef.extra,
          type: latestDef.type,
          isDeleted: false,
          teamId: teamId !== undefined ? teamId : x.teamId,
          public: isPublic !== undefined ? isPublic : x.public,
          creatorUserId: userId !== undefined ? userId : x.creatorUserId,
        };
      });
      await this.toolsRepository.save(entitiesToUpdate);
    }
  }

  public async listTools(teamId: string) {
    return await this.toolsRepository.find({
      where: [
        {
          isDeleted: false,
          public: true,
        },
        {
          isDeleted: false,
          teamId,
        },
      ],
    });
  }

  public async getToolByName(name: string) {
    return await this.toolsRepository.findOne({
      where: {
        name,
        isDeleted: false,
      },
    });
  }

  public async listServers() {
    return await this.toolsServerRepository.find({
      where: {
        isDeleted: false,
      },
    });
  }

  public async listServerHasHealthCheckEndpoint() {
    return await this.toolsServerRepository.find({
      where: {
        isDeleted: false,
        heatlhCheck: Not(IsNull()),
      },
    });
  }

  public async createTool(tool: ToolsEntity) {
    return await this.toolsRepository.save(tool);
  }

  public async updateToolServer(namespace: string, updates: Partial<ToolsServerEntity>) {
    await this.toolsRepository.update(
      {
        namespace,
        isDeleted: false,
      },
      updates,
    );
  }

  public async getToolsByNames(names: string[]) {
    if (!names?.length) {
      return [];
    }
    return await this.toolsRepository.find({
      where: {
        name: In(names),
        isDeleted: false,
      },
    });
  }
}

================================================================================

repositories/trigger-type.repository.ts:
--------------------------------------------------------------------------------
import { TriggerDefinition } from '@/common/typings/tools';
import { generateDbId } from '@/common/utils';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { In, Repository } from 'typeorm';
import { ToolsTriggerTypesEntity } from '../entities/tools/tools-trigger-types';

@Injectable()
export class TriggerTypeRepository {
  constructor(
    @InjectRepository(ToolsTriggerTypesEntity)
    private readonly triggerTypesRepository: Repository<ToolsTriggerTypesEntity>,
  ) {}

  public async createOrUpdateTriggerTypes(namespace: string, latestTriggers: TriggerDefinition[]) {
    latestTriggers = latestTriggers.map((x) => {
      x.type = `${namespace}__${x.type}`;
      return x;
    });
    const latestTypes = latestTriggers.map((x) => x.type);
    const originalCredentials = await this.triggerTypesRepository.find({
      where: {
        namespace,
        isDeleted: false,
      },
    });
    const originalTypes = originalCredentials.map((x) => x.type);
    const toDelete = originalCredentials.filter((x) => !latestTypes.includes(x.type));
    const toCreate = latestTriggers.filter((x) => !originalTypes.includes(x.type));
    const toUpdate = originalCredentials.filter((x) => latestTypes.includes(x.type));

    if (toCreate.length) {
      const entitiesToCreate: ToolsTriggerTypesEntity[] = toCreate.map(
        (x): ToolsTriggerTypesEntity => ({
          id: generateDbId(),
          isDeleted: false,
          createdTimestamp: +new Date(),
          updatedTimestamp: +new Date(),
          namespace: namespace,
          type: x.type,
          displayName: x.displayName,
          description: x.description,
          icon: x.icon,
          properties: x.properties,
          workflowInputs: x.workflowInputs,
        }),
      );
      await this.triggerTypesRepository.save(entitiesToCreate);
    }

    if (toDelete.length) {
      await this.triggerTypesRepository.update(
        {
          namespace,
          type: In(toDelete.map((x) => x.type)),
        },
        {
          isDeleted: true,
        },
      );
    }

    if (toUpdate.length) {
      const entitiesToUpdate = toUpdate.map((x): ToolsTriggerTypesEntity => {
        const latestDef = latestTriggers.find((t) => x.type === t.type);
        return {
          ...x,
          id: x.id,
          updatedTimestamp: +new Date(),
          displayName: latestDef.displayName,
          description: latestDef.description,
          icon: latestDef.icon,
          properties: latestDef.properties,
          type: latestDef.type,
          workflowInputs: latestDef.workflowInputs,
        };
      });
      await this.triggerTypesRepository.save(entitiesToUpdate);
    }
  }

  public async listTriggerTypes() {
    return await this.triggerTypesRepository.find({
      where: {
        isDeleted: false,
      },
    });
  }

  public async getTriggerType(type: string) {
    return this.triggerTypesRepository.findOne({
      where: {
        type,
      },
    });
  }
}

================================================================================

repositories/user.repository.ts:
--------------------------------------------------------------------------------
import { AuthMethod } from '@/common/config';
import { S3Helpers } from '@/common/s3';
import { generateDbId } from '@/common/utils';
import { getMap } from '@/common/utils/map';
import { UserEntity } from '@/database/entities/identity/user';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import _ from 'lodash';
import { In, Like, Repository } from 'typeorm';

const defaultAvatar = 'https://static.aside.fun/upload/frame/0XMWE1.jpg';
export const OBJECT_ID_PATTERN = /[0-9][0-9a-z]{23}/;

export interface RegisterUserParams {
  name?: string;
  phone?: string;
  email?: string;
  password?: string;
  photo?: string;
  externalId?: string;
}

export interface RegisterOrUpdateUserParams {
  name?: string;
  phone?: string;
  email?: string;
  photo?: string;
  externalId?: string;
}

@Injectable()
export class UserRepository {
  constructor(
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
  ) {}

  private async refreshLogo(users: UserEntity[]) {
    const promises = users.filter(Boolean).map(async (user) => {
      if (user.photo) {
        try {
          const s3Helpers = new S3Helpers();
          const { refreshed, refreshedUrl } = await s3Helpers.refreshSignedUrl(user.photo);
          if (refreshed) {
            user.photo = refreshedUrl;
            await this.userRepository.save(user);
          }
        } catch (e) {}
      }
    });
    await Promise.all(promises);
  }

  public async findById(userId: string) {
    const user = await this.userRepository.findOne({
      where: {
        id: userId,
        isDeleted: false,
      },
    });
    await this.refreshLogo([user]);
    return user;
  }

  public async findByIds(userIds: string[]) {
    const users = await this.userRepository.find({
      where: {
        id: In(userIds),
        isDeleted: false,
      },
    });
    await this.refreshLogo(users);
    return users;
  }

  public async findByEmail(email: string) {
    return await this.userRepository.findOne({
      where: {
        email,
        isDeleted: false,
      },
    });
  }

  public async findByKeyword(keyword: string) {
    const regex = Like(`%${keyword}%`);
    return await this.userRepository.find({
      where: [{ name: regex }, { phone: regex }, { email: regex }, { nickname: regex }],
      take: 50,
    });
  }

  public async findByExternalId(externalId: string) {
    return await this.userRepository.findOne({
      where: {
        externalId,
        isDeleted: false,
      },
    });
  }

  public async updateUserLastLogin(userId: string, authMethod: AuthMethod) {
    const user = await this.findById(userId);
    if (user) {
      user.lastLoginAt = Date.now();
      user.loginsCount = (user.loginsCount || 0) + 1;
      user.lastAuthMethod = authMethod;
      await this.userRepository.save(user);
    }
  }

  public async registerUser(data: RegisterUserParams) {
    const { phone, email, name, password, photo, externalId } = data;
    return await this.userRepository.save({
      id: generateDbId(),
      name: name || phone || email,
      phone,
      email,
      password,
      photo: photo || defaultAvatar,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      lastLoginAt: Date.now(),
      isDeleted: false,
      isBlocked: false,
      externalId,
    });
  }

  async registryOrGetUser(data: RegisterOrUpdateUserParams) {
    const { phone, email, externalId, photo, name } = data;
    if (!phone && !email && !externalId) {
      throw new Error('用户信息必须包含手机号、邮箱或者唯一 ID');
    }

    const userMatchByPhone = phone
      ? await this.userRepository.findOne({
          where: {
            phone,
            isDeleted: false,
          },
        })
      : null;
    const userMatchByEmail = email
      ? await this.userRepository.findOne({
          where: {
            email,
            isDeleted: false,
          },
        })
      : null;
    const userMatchByExternalId = externalId
      ? await this.userRepository.findOne({
          where: {
            externalId,
            isDeleted: false,
          },
        })
      : null;

    const matchCount = _.uniq([userMatchByEmail, userMatchByPhone, userMatchByExternalId].filter(Boolean).map((x) => x.id)).length;
    if (matchCount === 0) {
      return this.registerUser(data);
    } else if (matchCount === 1) {
      const user = [userMatchByEmail, userMatchByPhone, userMatchByExternalId].filter(Boolean)[0];
      user.email = email;
      user.phone = phone;
      user.externalId = externalId;
      user.photo = photo;
      user.name = name;
      await this.userRepository.save(user);
      return user;
    } else {
      throw new Error('此 OIDC 用户通过邮箱、手机号、唯一 ID 匹配到了系统中的多个用户');
    }
  }

  async updateUserInfo(userId: string, data: { name?: string; photo?: string }) {
    const user = await this.findById(userId);
    if (!user) {
      throw new Error('用户不存在');
    }
    const { name, photo } = data;
    const updates: Partial<UserEntity> = {};
    if (name) updates.name = name;
    if (photo) updates.photo = photo;
    if (JSON.stringify(updates) === '{}') {
      throw new Error('暂无需要变更的资料');
    }
    await this.userRepository.update(
      {
        id: userId,
      },
      updates,
    );
    return {
      success: true,
    };
  }

  async updateUser(userId: string, data: Partial<UserEntity>) {
    await this.userRepository.update(
      {
        id: userId,
      },
      data,
    );
  }

  public async getUsersByIdsAsMap(ids: string[]) {
    let userHash: Record<string, UserEntity> = {};
    if (ids?.length) {
      const users = await this.userRepository.find({
        where: {
          id: In(ids),
          isDeleted: false,
        },
      });
      userHash = getMap(users, (u) => u.id);
    }
    return userHash;
  }
}

================================================================================

repositories/workflow.repository.ts:
--------------------------------------------------------------------------------
import { config } from '@/common/config';
import { ListDto } from '@/common/dto/list.dto';
import { WorkflowStatusEnum } from '@/common/dto/status.enum';
import { generateDbId } from '@/common/utils';
import { getNextCronTimestamp } from '@/common/utils/cron';
import { calcMd5 } from '@/common/utils/utils';
import { WorkflowChatSessionEntity } from '@/database/entities/workflow/workflow-chat-session';
import { WorkflowExecutionEntity } from '@/database/entities/workflow/workflow-execution';
import { WorkflowMetadataEntity, WorkflowOutputValue, WorkflowRateLimiter, WorkflowValidationIssue } from '@/database/entities/workflow/workflow-metadata';
import { WorkflowPageGroupEntity } from '@/database/entities/workflow/workflow-page-group';
import { WorkflowTriggersEntity, WorkflowTriggerType } from '@/database/entities/workflow/workflow-trigger';
import { I18nValue, MonkeyTaskDefTypes, ToolProperty } from '@inf-monkeys/monkeys';
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import _, { isEmpty, isString, keyBy, omit, pick } from 'lodash';
import { ChatCompletionMessageParam } from 'openai/resources';
import { In, IsNull, Repository } from 'typeorm';
import { PageInstance, WorkflowPageEntity } from '../entities/workflow/workflow-page';
import { WorkflowAssetRepositroy } from './assets-workflow.respository';

export const BUILT_IN_PAGE_INSTANCES: PageInstance[] = [
  {
    name: '流程视图',
    type: 'process',
    allowedPermissions: ['read', 'write', 'exec', 'permission'],
    icon: '🚀',
  },
  {
    name: '日志视图',
    type: 'log',
    allowedPermissions: ['read', 'write'],
    icon: '📃',
  },
  {
    name: '预览视图',
    type: 'preview',
    allowedPermissions: ['read', 'write', 'exec', 'permission'],
    icon: '📷',
  },
  {
    name: '对话视图',
    type: 'chat',
    allowedPermissions: ['read', 'write', 'exec', 'permission'],
    icon: '💬',
  },
];

export interface FindWorkflowCondition {
  teamId: string;
  workflowId?: string;
  creatorUserId?: string;
}

@Injectable()
export class WorkflowRepository {
  constructor(
    @InjectRepository(WorkflowExecutionEntity)
    private readonly workflowExecutionRepository: Repository<WorkflowExecutionEntity>,
    @InjectRepository(WorkflowMetadataEntity)
    private readonly workflowMetadataRepository: Repository<WorkflowMetadataEntity>,
    @InjectRepository(WorkflowTriggersEntity)
    private readonly workflowTriggerRepository: Repository<WorkflowTriggersEntity>,
    @InjectRepository(WorkflowChatSessionEntity)
    private readonly workflowChatSessionRepository: Repository<WorkflowChatSessionEntity>,
    private readonly workflowAssetRepository: WorkflowAssetRepositroy,
    @InjectRepository(WorkflowPageEntity)
    private readonly pageRepository: Repository<WorkflowPageEntity>,
    @InjectRepository(WorkflowPageGroupEntity)
    private readonly pageGroupRepository: Repository<WorkflowPageGroupEntity>,
  ) {}

  public async findWorkflowByCondition(condition: FindWorkflowCondition) {
    return await this.workflowMetadataRepository.find({
      where: {
        ...condition,
        isDeleted: false,
      },
    });
  }

  public async createWorkflow(
    teamId: string,
    userId: string,
    workflowId: string,
    version: number,
    data: {
      displayName: string | I18nValue;
      description?: string | I18nValue;
      iconUrl?: string;
      tasks: MonkeyTaskDefTypes[];
      variables?: ToolProperty[];
      output: WorkflowOutputValue[];
      exposeOpenaiCompatibleInterface?: boolean;
      rateLimiter?: WorkflowRateLimiter;
      validationIssues?: WorkflowValidationIssue[];
      validated?: boolean;
      shortcutsFlow?: string;
    },
    useNewId = false,
  ) {
    const { displayName, description, iconUrl, tasks, variables, output, exposeOpenaiCompatibleInterface, shortcutsFlow, rateLimiter, validationIssues = [], validated = true } = data;

    const id = useNewId ? generateDbId() : workflowId;

    await this.workflowMetadataRepository.save({
      id,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      isDeleted: false,
      workflowId,
      version,
      teamId: teamId,
      creatorUserId: userId,
      displayName,
      description,
      iconUrl,
      tasks,
      variables,
      output,
      exposeOpenaiCompatibleInterface,
      rateLimiter,
      validationIssues,
      validated,
      shortcutsFlow,
    });
    return await this.getWorkflowById(workflowId, version);
  }

  public async getWorkflowById(workflowId: string, version: number, throwError = true) {
    const workflow = await this.workflowMetadataRepository.findOne({
      where: {
        workflowId,
        version,
        isDeleted: false,
      },
    });
    if (!workflow && throwError) {
      throw new NotFoundException(`Workflow ${workflowId} not found`);
    }
    return workflow;
  }

  public async getWorkflowByIdWithoutVersion(workflowId: string, throwError = true) {
    const maxVersion = await this.getMaxVersion(workflowId);
    return await this.getWorkflowById(workflowId, maxVersion, throwError);
  }

  public async findWorkflowByIds(workflowIds: string[]) {
    if (!workflowIds?.length) {
      return [];
    }
    return await this.workflowMetadataRepository.find({
      where: {
        workflowId: In(workflowIds),
        isDeleted: false,
      },
    });
  }

  public async getAllWorkflowsInTeam(teamId: string) {
    return await this.workflowMetadataRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });
  }

  private calcWorkflowMd5(workflow: Partial<WorkflowMetadataEntity>) {
    const str = JSON.stringify(_.pick(workflow, ['tasks', 'variables', 'output'] as (keyof WorkflowMetadataEntity)[]));
    return calcMd5(str);
  }

  async updateWorkflowDef(
    teamId: string,
    workflowId: string,
    version: number,
    updates: {
      displayName?: string;
      description?: string;
      iconUrl?: string;
      tasks?: MonkeyTaskDefTypes[];
      variables?: ToolProperty[];
      activated?: boolean;
      validated?: boolean;
      validationIssues?: WorkflowValidationIssue[];
      output?: WorkflowOutputValue[];
      tagIds?: string[];
      rateLimiter?: WorkflowRateLimiter;
      exposeOpenaiCompatibleInterface?: boolean;
      openaiModelName?: string;
      shortcutsFlow?: string;
    },
  ) {
    const {
      displayName,
      description,
      iconUrl,
      tasks,
      variables,
      activated,
      validationIssues,
      validated,
      output,
      tagIds,
      rateLimiter,
      exposeOpenaiCompatibleInterface,
      openaiModelName,
      shortcutsFlow,
    } = updates;

    // 字段都为空，则跳过更新
    if (
      [displayName, description, iconUrl, tasks, variables, activated, validated, validationIssues, output, tagIds, rateLimiter, exposeOpenaiCompatibleInterface, openaiModelName, shortcutsFlow].every(
        (item) => typeof item === 'undefined',
      )
    )
      return;
    if (variables && !Array.isArray(variables)) {
      throw new Error('variables 字段必须为数组');
    }
    if (output && !Array.isArray(output)) {
      throw new Error('output 字段必须为数组');
    }

    // 检查 shortcutsFlow 对应的工作流是否存在
    if (isString(shortcutsFlow)) {
      const [shortcutsFlowId, shortcutsFlowVersionString] = shortcutsFlow.split(':');
      if (!(await this.checkWorkflowExists(shortcutsFlowId, parseInt(shortcutsFlowVersionString)))) {
        throw new Error('shortcutsFlow 对应的工作流不存在');
      }
      if (shortcutsFlowId === workflowId) {
        throw new Error('shortcutsFlow 不能指向自身');
      }
      // 此处应有授权逻辑
    }

    // Check if openaiModelName is unique
    if (openaiModelName) {
      const existingWorkflow = await this.findWorkflowByOpenAIModelName(teamId, openaiModelName);
      if (existingWorkflow && existingWorkflow.workflowId !== workflowId) {
        throw new Error('openaiModelName must be unique');
      }
    }

    await this.workflowMetadataRepository.findOneOrFail({ where: { workflowId: workflowId, version, teamId, isDeleted: false } });
    const updateFields = {
      ..._.pickBy(
        { displayName, iconUrl, description, tasks, variables, activated, validationIssues, validated, output, tagIds, rateLimiter, exposeOpenaiCompatibleInterface, openaiModelName, shortcutsFlow },
        (v) => typeof v !== 'undefined',
      ),
      updatedTimestamp: Date.now(),
    };
    await this.workflowMetadataRepository.update({ workflowId, isDeleted: false, teamId, version }, updateFields);
    const workflow = await this.workflowMetadataRepository.findOne({
      where: {
        teamId,
        workflowId,
        version,
        isDeleted: false,
      },
    });
    workflow.md5 = this.calcWorkflowMd5(workflow);
    await this.workflowMetadataRepository.save(workflow);
    return workflow;
  }

  public async findExecutionsByWorkflowInstanceIds(workflowInstanceIds: string[]) {
    if (!workflowInstanceIds?.length) {
      return [];
    }
    return await this.workflowExecutionRepository.find({
      where: {
        workflowInstanceId: In(workflowInstanceIds),
      },
    });
  }

  public async findExecutionsByChatSessionId(chatSessionId: string) {
    return await this.workflowExecutionRepository.find({
      where: {
        chatSessionId: chatSessionId,
      },
    });
  }

  public async findExecutionsByChatSessionIds(chatSessionIds: string[]) {
    if (!chatSessionIds?.length) {
      return [];
    }
    return await this.workflowExecutionRepository.find({
      where: {
        chatSessionId: In(chatSessionIds),
      },
    });
  }

  public async findExecutionsByGroup(group: string) {
    return await this.workflowExecutionRepository.find({
      where: {
        group,
      },
    });
  }

  public async findExecutionsByGroups(groups: string[]) {
    if (!groups?.length) {
      return [];
    }
    return await this.workflowExecutionRepository.find({
      where: {
        group: In(groups),
      },
    });
  }

  public async findExecutionsByTriggerTypes(triggerTypes: WorkflowTriggerType[]) {
    if (!triggerTypes?.length) {
      return [];
    }
    return await this.workflowExecutionRepository.find({
      where: {
        triggerType: In(triggerTypes),
      },
    });
  }

  public async findExecutionsByUserIds(userIds: string[]) {
    if (!userIds?.length) {
      return [];
    }
    return await this.workflowExecutionRepository.find({
      where: {
        userId: In(userIds),
      },
    });
  }

  public async deleteWorkflow(teamId: string, workflowId: string) {
    await this.workflowMetadataRepository.update(
      {
        teamId,
        workflowId,
      },
      {
        isDeleted: true,
      },
    );
    await this.workflowTriggerRepository.update(
      {
        workflowId,
      },
      {
        isDeleted: true,
      },
    );
    await this.pageRepository.update(
      {
        workflowId,
      },
      {
        isDeleted: true,
      },
    );
  }

  public async getWorkflowVersions(workflowId: string) {
    return await this.workflowMetadataRepository.find({
      where: {
        workflowId,
        isDeleted: false,
      },
    });
  }

  public async getMaxVersion(workflowId: string) {
    const versions = await this.workflowMetadataRepository.find({
      where: {
        workflowId,
      },
    });
    if (versions?.length === 0) {
      return 1;
    }
    return Math.max(...versions.map((x) => x.version));
  }

  public async findWebhookTrigger(webhookPath: string) {
    return await this.workflowTriggerRepository.findOne({
      where: {
        type: WorkflowTriggerType.WEBHOOK,
        webhookPath,
      },
    });
  }

  public async saveWorkflowExecution({
    workflowId,
    version,
    workflowInstanceId,
    userId,
    triggerType,
    chatSessionId,
    apiKey,
    group,
  }: {
    workflowId: string;
    version: number;
    workflowInstanceId: string;
    userId: string;
    triggerType: WorkflowTriggerType;
    chatSessionId?: string;
    apiKey: string;
    group?: string;
  }) {
    await this.workflowExecutionRepository.save({
      id: generateDbId(),
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      isDeleted: false,
      workflowId,
      workflowVersion: version,
      workflowInstanceId,
      userId,
      triggerType,
      chatSessionId,
      apikey: apiKey,
      group,
    });
  }

  public async updateWorkflowExecutionStatus(workflowInstanceId: string, status: WorkflowStatusEnum, takes: number) {
    await this.workflowExecutionRepository.update(
      {
        workflowInstanceId,
      },
      {
        status,
        updatedTimestamp: Date.now(),
        takes,
      },
    );
  }

  public async fetchWorkflowExecutionWithNoStatus() {
    return await this.workflowExecutionRepository.findOne({
      where: [
        {
          status: IsNull(),
        },
        {
          status: WorkflowStatusEnum.RUNNING,
        },
      ],
    });
  }

  private getDateList(startTimestamp: number, endTimestamp: number) {
    const startDate = new Date(startTimestamp);
    const endDate = new Date(endTimestamp);
    endDate.setDate(endDate.getDate() + 1);

    const dateList = [];
    const currentDate = startDate;

    while (currentDate <= endDate) {
      const year = currentDate.getFullYear();
      const month = String(currentDate.getMonth() + 1).padStart(2, '0');
      const day = String(currentDate.getDate()).padStart(2, '0');

      dateList.push(`${year}-${month}-${day}`);

      // Move to the next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return dateList;
  }

  public async getWorkflowExecutionStatisticsByWorkflowId(workflowId: string, startTimestamp: number, endTimestamp: number, onlyGroup?: boolean) {
    const appId = config.server.appId;
    const groupCondition = onlyGroup ? `"group" LIKE 'shortcut-%'` : `("group" IS NULL OR "group" NOT LIKE 'shortcut-%')`;

    const callsPerDateSql = `
SELECT
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_workflow_execution
WHERE workflow_id = '${workflowId}' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
  AND ${groupCondition}
GROUP BY
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    workflow_id,
    date;
    `;

    const successPerDateSql = `
SELECT
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_workflow_execution
WHERE workflow_id = '${workflowId}' AND status = 'COMPLETED' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
  AND ${groupCondition}
GROUP BY
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    workflow_id,
    date;
`;

    const failedPerDateSql = `
SELECT
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_workflow_execution
WHERE workflow_id = '${workflowId}' AND status in ('FAILED','TERMINATED','PAUSED') AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
  AND ${groupCondition}
GROUP BY
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    workflow_id,
    date;
`;

    const averageTakesPerDateSql = `
SELECT
  workflow_id,
  TO_CHAR(TO_TIMESTAMP(created_timestamp / 1000), 'YYYY-MM-DD') AS date,
  AVG(takes) AS average_time
FROM
  ${appId}_workflow_execution
WHERE
  status = 'COMPLETED' AND workflow_id = '${workflowId}' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
  AND ${groupCondition}
GROUP BY
  workflow_id,
  date
ORDER BY
  workflow_id,
  date;
    `;

    const dateList = this.getDateList(startTimestamp, endTimestamp);
    const [callsPerDayResult, successPerDayResult, failedPerDayResult, averageTakesPerDayResult] = await Promise.all([
      this.workflowExecutionRepository.query(callsPerDateSql),
      this.workflowExecutionRepository.query(successPerDateSql),
      this.workflowExecutionRepository.query(failedPerDateSql),
      this.workflowExecutionRepository.query(averageTakesPerDateSql),
    ]);

    const result: Array<{
      date: string;
      totalCount: number;
      successCount: number;
      failedCount: number;
      averageTime: number;
    }> = [];
    for (const date of dateList) {
      const callsPerDay = callsPerDayResult.find((x: { date: any }) => x.date === date);
      const successPerDay = successPerDayResult.find((x: { date: any }) => x.date === date);
      const failedPerDay = failedPerDayResult.find((x: { date: any }) => x.date === date);
      const averageTakesPerDay = averageTakesPerDayResult.find((x: { date: any }) => x.date === date);
      result.push({
        date,
        totalCount: parseInt(callsPerDay?.total_calls) || 0,
        successCount: parseInt(successPerDay?.total_calls) || 0,
        failedCount: parseInt(failedPerDay?.total_calls) || 0,
        averageTime: parseInt(averageTakesPerDay?.average_time) || 0,
      });
    }
    return result;
  }

  public async getWorkflowExecutionStatisticsByTeamId(teamId: string, startTimestamp: number, endTimestamp: number) {
    const dateList = this.getDateList(startTimestamp, endTimestamp);

    const appId = config.server.appId;
    const workflowIds = _.uniq(
      (
        await this.workflowMetadataRepository.find({
          where: {
            teamId,
          },
          select: ['workflowId'],
        })
      ).map((x) => x.workflowId),
    );

    if (workflowIds.length === 0) {
      return dateList.map((date) => {
        return {
          date,
          totalCount: 0,
          successCount: 0,
          failedCount: 0,
          averageTime: 0,
        };
      });
    }

    const workflowIdsStr = workflowIds.map((x) => `'${x}'`).join(',');
    const callsPerDateSql = `
SELECT
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_workflow_execution
WHERE workflow_id IN (${workflowIdsStr}) AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    workflow_id,
    date;
    `;

    const successPerDateSql = `
SELECT
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_workflow_execution
WHERE workflow_id IN (${workflowIdsStr}) AND status = 'COMPLETED' AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    workflow_id,
    date;
`;

    const failedPerDateSql = `
SELECT
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/ 1000), 'YYYY-MM-DD') AS date,
    COUNT(*) AS total_calls
FROM
    ${appId}_workflow_execution
WHERE workflow_id IN (${workflowIdsStr}) AND status in ('FAILED','TERMINATED','PAUSED') AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
    workflow_id,
    TO_CHAR(TO_TIMESTAMP(created_timestamp/1000), 'YYYY-MM-DD')
ORDER BY
    workflow_id,
    date;
`;

    const averageTakesPerDateSql = `
SELECT
  workflow_id,
  TO_CHAR(TO_TIMESTAMP(created_timestamp / 1000), 'YYYY-MM-DD') AS date,
  AVG(takes) AS average_time
FROM
  ${appId}_workflow_execution
WHERE
  status = 'COMPLETED' AND workflow_id IN (${workflowIdsStr}) AND created_timestamp >= ${startTimestamp} AND created_timestamp <= ${endTimestamp}
GROUP BY
  workflow_id,
  date
ORDER BY
  workflow_id,
  date;
    `;

    const [callsPerDayResult, successPerDayResult, failedPerDayResult, averageTakesPerDayResult] = await Promise.all([
      this.workflowExecutionRepository.query(callsPerDateSql),
      this.workflowExecutionRepository.query(successPerDateSql),
      this.workflowExecutionRepository.query(failedPerDateSql),
      this.workflowExecutionRepository.query(averageTakesPerDateSql),
    ]);

    const result: Array<{
      date: string;
      totalCount: number;
      successCount: number;
      failedCount: number;
      averageTime: number;
    }> = [];
    for (const date of dateList) {
      const callsPerDay = callsPerDayResult.find((x: { date: any }) => x.date === date);
      const successPerDay = successPerDayResult.find((x: { date: any }) => x.date === date);
      const failedPerDay = failedPerDayResult.find((x: { date: any }) => x.date === date);
      const averageTakesPerDay = averageTakesPerDayResult.find((x: { date: any }) => x.date === date);
      result.push({
        date,
        totalCount: parseInt(callsPerDay?.total_calls) || 0,
        successCount: parseInt(successPerDay?.total_calls) || 0,
        failedCount: parseInt(failedPerDay?.total_calls) || 0,
        averageTime: parseInt(averageTakesPerDay?.average_time) || 0,
      });
    }
    return result;
  }

  public async deleteTrigger(workflowId: string, triggerId: string) {
    return await this.workflowTriggerRepository.update(
      {
        id: triggerId,
        workflowId,
      },
      {
        isDeleted: true,
      },
    );
  }

  public async listWorkflowTriggers(workflowId: string, version: number) {
    return await this.workflowTriggerRepository.find({
      where: {
        workflowId,
        isDeleted: false,
        workflowVersion: version,
      },
    });
  }

  public async createWorkflowTrigger(data: Partial<WorkflowTriggersEntity>) {
    const entity: Partial<WorkflowTriggersEntity> = {
      ...data,
      createdTimestamp: Date.now(),
      updatedTimestamp: Date.now(),
      isDeleted: false,
    };
    await this.workflowTriggerRepository.save(entity);
  }

  public async getWorkflowTrigger(triggerId: string) {
    return await this.workflowTriggerRepository.findOne({
      where: {
        id: triggerId,
        isDeleted: false,
      },
    });
  }

  public async saveWorkflowTrigger(entity: WorkflowTriggersEntity) {
    return await this.workflowTriggerRepository.save(entity);
  }

  public async disableAllTriggers(workflowId: string) {
    await this.workflowTriggerRepository.update(
      {
        workflowId,
      },
      {
        enabled: false,
      },
    );
  }

  public async getTriggersToRun() {
    const currentTimestamp = +new Date();
    const query = this.workflowTriggerRepository
      .createQueryBuilder('workflow_trigger')
      .where('workflow_trigger.enabled = :enabled', { enabled: true })
      .andWhere('workflow_trigger.type = :type', { type: WorkflowTriggerType.SCHEDULER })
      .andWhere('(workflow_trigger.next_trigger_time IS NULL OR workflow_trigger.next_trigger_time < :currentTimestamp)', { currentTimestamp })
      .andWhere('workflow_trigger.is_deleted = :isDeleted', { isDeleted: false });
    return await query.getMany();
  }

  public async updateNextTriggerTime(currentTimestamp: number, triggers: WorkflowTriggersEntity[]) {
    const triggersToUpdate = triggers.map((x) => {
      x.nextTriggerTime = getNextCronTimestamp(x.cron);
      x.lastTriggerTime = currentTimestamp;
      return x;
    });
    await this.workflowTriggerRepository.save(triggersToUpdate);
  }

  public async createChatSession(teamId: string, userId: string, workflowId: string, displayName: string) {
    const id = generateDbId();
    const timestamp = +new Date();
    const entity: Partial<WorkflowChatSessionEntity> = {
      id: id,
      displayName,
      workflowId,
      teamId,
      creatorUserId: userId,
      createdTimestamp: timestamp,
      updatedTimestamp: timestamp,
      isDeleted: false,
    };
    await this.workflowChatSessionRepository.save(entity);
    return entity;
  }

  public async listChatSessions(teamId: string, workflowId: string) {
    return await this.workflowChatSessionRepository.find({
      where: {
        teamId,
        workflowId,
        isDeleted: false,
      },
      select: ['id', 'displayName', 'createdTimestamp', 'updatedTimestamp', 'creatorUserId', 'isDeleted', 'teamId', 'workflowId'],
      order: {
        id: 'DESC',
      },
    });
  }

  public async getChatSessionMessages(teamId: string, sessionId: string): Promise<Array<ChatCompletionMessageParam>> {
    const session = await this.workflowChatSessionRepository.findOne({
      where: {
        id: sessionId,
        isDeleted: false,
        teamId,
      },
    });
    if (!session) {
      return [];
    }
    return session?.messages || [];
  }

  public async deleteChatSession(teamId: string, sessionId: string) {
    await this.workflowChatSessionRepository.update(
      {
        id: sessionId,
        teamId,
        isDeleted: false,
      },
      {
        isDeleted: true,
      },
    );
    return {
      success: true,
    };
  }

  public async updateChatSession(teamId: string, sessionId: string, updates: Partial<WorkflowChatSessionEntity>) {
    await this.workflowChatSessionRepository.update(
      {
        id: sessionId,
        teamId,
        isDeleted: false,
      },
      updates,
    );
    return {
      success: true,
    };
  }

  public async updateChatSessionMessages(teamId: string, sessionId: string, messages: Array<ChatCompletionMessageParam>) {
    await this.workflowChatSessionRepository.update(
      {
        id: sessionId,
        teamId,
        isDeleted: false,
      },
      {
        messages,
      },
    );
    return {
      success: true,
    };
  }

  public async getAllWorkflows(teamId: string) {
    return await this.workflowMetadataRepository.find({
      where: {
        teamId,
        isDeleted: false,
      },
    });
  }

  public async listWorkflows(
    teamId: string,
    dto: ListDto,
  ): Promise<{
    totalCount: number;
    list: WorkflowMetadataEntity[];
  }> {
    const { page = 1, limit = 24, orderBy = 'DESC', orderColumn = 'createdTimestamp', filter } = dto;

    // Prepare a subquery to find the latest version for each workflow.
    const latestVersionSubquery = this.workflowMetadataRepository
      .createQueryBuilder('w')
      .select('w.workflow_id', 'workflow_id')
      .addSelect('MAX(w.version)', 'max_version')
      .where('w.team_id = :teamId', { teamId })
      .andWhere('w.is_deleted = false')
      .andWhere('w.is_published = false')
      .groupBy('w.workflow_id');

    if (filter) {
      // Apply any additional filters here using your `findAssetIdsByCommonFilter` logic.
      const workflowIds = await this.workflowAssetRepository.findAssetIdsByCommonFilter('workflow', filter, 'workflowId');
      if (workflowIds.length === 0) {
        return { totalCount: 0, list: [] };
      }
      latestVersionSubquery.andWhere('w.workflow_id IN (:...workflowIds)', { workflowIds });
    }

    const workflowsQueryBuilder = this.workflowMetadataRepository
      .createQueryBuilder('w')
      .innerJoin(`(${latestVersionSubquery.getQuery()})`, 'latest', 'w.workflow_id = latest.workflow_id AND w.version = latest.max_version AND w.is_published = false')
      .setParameters(latestVersionSubquery.getParameters());

    // Count total number of workflows
    const totalCount = await workflowsQueryBuilder.getCount();

    // Apply ordering
    const validOrderColumns = {
      createdTimestamp: 'w.created_timestamp',
      updatedTimestamp: 'w.updated_timestamp',
    };
    const orderColumnSql = validOrderColumns[orderColumn] || 'w.created_timestamp';

    // Apply pagination
    const workflows = await workflowsQueryBuilder
      .orderBy(orderColumnSql, orderBy.toUpperCase() === 'ASC' ? 'ASC' : 'DESC')
      .limit(limit)
      .offset((page - 1) * limit)
      .getMany();

    return {
      totalCount,
      list: workflows,
    };
  }

  async listWorkflowPagesAndCreateIfNotExists(workflowId: string) {
    const workflow = await this.getWorkflowByIdWithoutVersion(workflowId);
    let pages: WorkflowPageEntity[];
    const existsPages = await this.pageRepository.find({
      where: {
        workflowId,
        isDeleted: false,
      },
      order: {
        sortIndex: 1,
      },
    });
    if (existsPages.length > 0) {
      pages = existsPages;
    } else {
      let sortIndex = 0;
      pages = BUILT_IN_PAGE_INSTANCES.map((item) => ({
        id: generateDbId(),
        type: item.type,
        displayName: item.name,
        workflowId,
        isBuiltIn: true,
        teamId: workflow.teamId,
        permissions: item.allowedPermissions, // 默认授予全部权限
        sortIndex: ++sortIndex,
        createdTimestamp: Date.now(),
        updatedTimestamp: Date.now(),
        isDeleted: false,
      }));
      await this.pageRepository.save(pages);
    }
    const pageInstanceTypeMapper = keyBy(BUILT_IN_PAGE_INSTANCES, 'type');
    return pages.map((page) => ({
      ...page,
      instance: pageInstanceTypeMapper[page.type],
    }));
  }

  async updatePagePinStatus(teamId: string, pageId: string, pin: boolean) {
    const defaultGroup = await this.getDefaultPageGroupAndCreateIfNotExists(teamId);

    if (pin) {
      if (!defaultGroup.pageIds.includes(pageId)) {
        defaultGroup.pageIds.push(pageId);
      }
    } else {
      const index = defaultGroup.pageIds.findIndex((id) => id === pageId);
      if (index !== -1) {
        defaultGroup.pageIds.splice(index, 1);
      }
    }

    await this.pageGroupRepository.save(defaultGroup);
  }

  public async getDefaultPageGroupAndCreateIfNotExists(teamId: string) {
    const defaultGroup = await this.pageGroupRepository.findOne({
      where: {
        teamId,
        isBuiltIn: true,
      },
    });
    if (!defaultGroup) {
      const group = this.pageGroupRepository.create({
        id: generateDbId(),
        displayName: '默认分组',
        isBuiltIn: true,
        teamId,
        pageIds: [],
        createdTimestamp: Date.now(),
        updatedTimestamp: Date.now(),
      });
      await this.pageGroupRepository.save(group);

      return group;
    }

    return defaultGroup;
  }

  public async getPageGroupsAndCreateIfNotExists(teamId: string, groupDisplayNames: string[]) {
    const existsGroups = await this.pageGroupRepository.find({
      where: {
        teamId,
        isBuiltIn: false,
      },
    });
    const defaultGroup = await this.getDefaultPageGroupAndCreateIfNotExists(teamId);

    const groups = groupDisplayNames.map((displayName) => {
      if (displayName === 'default') {
        return defaultGroup;
      }

      const existsGroup = existsGroups.find((group) => group.displayName === displayName);
      if (existsGroup) {
        return existsGroup;
      }

      return this.pageGroupRepository.create({
        id: generateDbId(),
        displayName,
        isBuiltIn: false,
        teamId,
        pageIds: [],
        createdTimestamp: Date.now(),
        updatedTimestamp: Date.now(),
      });
    });

    await this.pageGroupRepository.save(groups);

    return groups;
  }

  public async updatePageGroup(groupId: string, updates: Partial<WorkflowPageGroupEntity>) {
    await this.pageGroupRepository.update(
      {
        id: groupId,
      },
      updates,
    );
  }

  public async listAllOpenAICompatibleWorkflows(teamId: string) {
    return await this.workflowMetadataRepository.find({
      where: {
        teamId,
        exposeOpenaiCompatibleInterface: true,
        isDeleted: false,
      },
    });
  }

  public async findWorkflowByOpenAIModelName(teamId: string, openaiModelName: string) {
    return await this.workflowMetadataRepository.findOne({
      where: {
        teamId,
        openaiModelName,
        isDeleted: false,
      },
    });
  }

  public async hasWorkflowUnauthorized(workflowId: string) {
    const workflow = await this.workflowMetadataRepository.findOne({
      where: {
        workflowId,
        isDeleted: false,
      },
    });
    return {
      userId: workflow?.creatorUserId,
      notAuthorized: workflow?.notAuthorized,
    };
  }

  public async toggleWorkflowUnauthorized(teamId: string, workflowId: string, notAuthorized: boolean) {
    return await this.workflowMetadataRepository.update(
      {
        workflowId,
        teamId,
      },
      {
        notAuthorized,
      },
    );
  }

  public async checkWorkflowExists(workflowId: string, version?: number) {
    return (
      (await this.workflowMetadataRepository.findOne({
        where: {
          workflowId,
          isDeleted: false,
          ...(version && { version }),
        },
      })) !== null
    );
  }

  public async convertWorkflowWhitShortcutsFlowId(workflowOrWorkflowId: WorkflowMetadataEntity | string, version?: number, targetWorkflow = false) {
    let workflow: WorkflowMetadataEntity | null;

    if (typeof workflowOrWorkflowId === 'string') {
      if (!version) {
        version = await this.getMaxVersion(workflowOrWorkflowId);
      }
      workflow = await this.getWorkflowById(workflowOrWorkflowId, version);
    } else {
      workflow = workflowOrWorkflowId;
    }

    const shortcutsFlow = workflow?.shortcutsFlow;
    if (shortcutsFlow) {
      const [workflowId, versionString] = shortcutsFlow.split(':');
      if (!isEmpty(workflowId)) {
        let shortcutsFlowVersion = parseInt(versionString);
        if (!shortcutsFlowVersion) {
          shortcutsFlowVersion = await this.getMaxVersion(workflowId);
        }

        const targetFlow = await this.getWorkflowById(workflowId, shortcutsFlowVersion, false);
        if (targetFlow) {
          if (isEmpty(targetFlow?.shortcutsFlow ?? null)) {
            if (targetWorkflow) {
              return targetFlow;
            }

            const targetKeys = [
              'tasks',
              'version',
              'updatedTimestamp',
              'iconUrl',
              'displayName',
              'description',
              'variables',
              'output',
              'md5',
              'exposeOpenaiCompatibleInterface',
              'openaiModelName',
            ] as (keyof WorkflowMetadataEntity)[];

            return {
              ...omit(workflow, targetKeys),
              ...pick(targetFlow, targetKeys),
            } as WorkflowMetadataEntity;
          }
        }
      }
    }

    return null;
  }
}

================================================================================

transformers/timestamp.transformer.ts:
--------------------------------------------------------------------------------
export const TimestampTransformer = {
  // 从数据库读取时，将 timestamp 转换为 number
  from: (value: Date | null): number | null => {
    return value ? value.getTime() : null;
  },
  // 写入数据库时，将 number 转换为 Date
  to: (value: number | null): Date | null => {
    return value ? new Date(value) : null;
  },
};

